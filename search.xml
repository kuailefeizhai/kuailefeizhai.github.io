<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>python challenge8</title>
    <url>/2020/07/16/python-challenge8/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/integrity.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc8-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>点击图片中的蜜蜂（看起来像苍蝇）会弹出表单让输入用户名和密码以及提示信息inflate（chrome打开没有）<br><img src="/image/pc8-2.png"><br>“inflate”膨胀的反义词是“compress”压缩。在网页源代码中有用户名和密码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">un: &#39;BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084&#39;</span><br><span class="line">pw: &#39;BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08&#39;</span><br><span class="line">--&gt;</span><br></pre></td></tr></table></figure>
<p>这个开头是bzip2的压缩格式，引入bz2进行压缩（需要先将str转换成byte）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import bz2</span><br><span class="line"></span><br><span class="line">un &#x3D; bz2.decompress(b&#39;BZh91AY&amp;SYA\xaf\x82\r\x00\x00\x01\x01\x80\x02\xc0\x02\x00 \x00!\x9ah3M\x07&lt;]\xc9\x14\xe1BA\x06\xbe\x084&#39;)</span><br><span class="line">pw &#x3D; bz2.decompress(b&#39;BZh91AY&amp;SY\x94$|\x0e\x00\x00\x00\x81\x00\x03$ \x00!\x9ah3M\x13&lt;]\xc9\x14\xe1BBP\x91\xf08&#39;)</span><br><span class="line"></span><br><span class="line">print(&#39;un &#x3D; &#39;, un)</span><br><span class="line">print(&#39;pw &#x3D; &#39;, pw)</span><br></pre></td></tr></table></figure>
<p>得到结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">un &#x3D;  b&#39;huge&#39;</span><br><span class="line">pw &#x3D;  b&#39;file&#39;</span><br></pre></td></tr></table></figure>
<p>将结果提交表单后跳转到下一题网址。</p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge7</title>
    <url>/2020/06/19/python-challenge7/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/oxygen.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc7-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目只有一张图片，网页源代码也没有内容，需要从图片中提取信息。<br>使用PIL(Pillow)库中的image：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line"></span><br><span class="line">img &#x3D; Image.open(&quot;oxygen.png&quot;)</span><br></pre></td></tr></table></figure>
<p>img内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[(115, 115, 115, 255), (115, 115, 115, 255), (115, 115, 115, 255), (115, 115, 115, 255), (115, 115, 115, 255), (109, 109, 109, 255), (109, 109, 109, 255), (109, 109, 109, 255), (109, 109, 109, 255), (109, 109, 109, 255), (109, 109, 109, 255), (109, 109, 109, 255), (97, 97, 97, 255), (97, 97, 97, 255), (97, 97, 97, 255),......]</span><br></pre></td></tr></table></figure>
<p>取图片中间灰色的部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">row &#x3D; [img.getpixel((x, img.height &#x2F; 2)) for x in range(img.width)]</span><br></pre></td></tr></table></figure>
<p>观察图片，在灰色区域的末尾有一段属于原图，剔除掉这部分，顺便去掉重复的元组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ords &#x3D; [r for r, g, b, a in row if r &#x3D;&#x3D; g &#x3D;&#x3D; b]</span><br><span class="line">ords &#x3D; ords[::7]</span><br></pre></td></tr></table></figure>
<p>由于图片灰度值的范围都在[0, 255]之间，所以可以把他们当成ascll码来翻译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&quot;.join(map(chr, ords)))</span><br></pre></td></tr></table></figure>
<p>得到译文：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">smart guy, you made it. the next level is [105, 110, 116, 101, 103, 114, 105, 116, 121]</span><br></pre></td></tr></table></figure>
<p>将这个结果按同样的规律翻译得到：integrity</p>
<p>标准答案：</p>
<p><a href="http://www.pythonchallenge.com/pcc/def/integrity.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/integrity.html</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge6</title>
    <url>/2020/06/18/python-challenge6/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/channel.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc6-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>网页源代码第一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt; &lt;!-- &lt;-- zip --&gt;</span><br></pre></td></tr></table></figure>
<p>将网址后缀改为channel.zip得到压缩文件channel.zip，如图所示，<br><img src="/image/pc6-2.png"></p>
<p>其中第一个文件为readme.txt，写着：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">welcome to my zipped list.</span><br><span class="line"></span><br><span class="line">hint1: start from 90052</span><br><span class="line">hint2: answer is inside the zip</span><br></pre></td></tr></table></figure>
<p>和python-challeng4类似，在压缩包中一直迭代寻找答案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import zipfile</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">zipFile &#x3D; zipfile.ZipFile(&#39;channel.zip&#39;, &#39;r&#39;)</span><br><span class="line">key &#x3D; &#39;90052&#39;</span><br><span class="line">while True:</span><br><span class="line">    data &#x3D; zipFile.read(key + &#39;.txt&#39;)</span><br><span class="line">    s &#x3D; str(data, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">    pattern &#x3D; re.compile(&#39;[0-9]+&#39;)</span><br><span class="line">    try:</span><br><span class="line">        key &#x3D; re.findall(pattern, s)[-1]</span><br><span class="line">    except:</span><br><span class="line">        break</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure>
<p>最后一个数字为46145，该文件写着：Collect the comments.<br>ZipFile.comment：<br>关联到 ZIP 文件的 bytes 对象形式的说明。 如果将说明赋给以 ‘w’, ‘x’ 或 ‘a’ 模式创建的 ZipFile 实例，它的长度不应超过65535 字节。 超过此长度的说明将被截断。<br>加一段代码来收集comments</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; num &#x3D; &#39;90052&#39;</span><br><span class="line">&gt;&gt;&gt; comments &#x3D; []</span><br><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     content &#x3D; f.read(num + &quot;.txt&quot;).decode(&quot;utf-8&quot;)</span><br><span class="line">...     comments.append(f.getinfo(num + &quot;.txt&quot;).comment.decode(&quot;utf-8&quot;))</span><br><span class="line">...     content</span><br><span class="line">...     match &#x3D; re.search(&quot;Next nothing is (\d+)&quot;, content)</span><br><span class="line">...     if match &#x3D;&#x3D; None:</span><br><span class="line">...         break</span><br><span class="line">...     num &#x3D; match.group(1)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(&quot;&quot;.join(comments))</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">****************************************************************</span><br><span class="line">****************************************************************</span><br><span class="line">**                                                            **</span><br><span class="line">**   OO    OO    XX      YYYY    GG    GG  EEEEEE NN      NN  **</span><br><span class="line">**   OO    OO  XXXXXX   YYYYYY   GG   GG   EEEEEE  NN    NN   **</span><br><span class="line">**   OO    OO XXX  XXX YYY   YY  GG GG     EE       NN  NN    **</span><br><span class="line">**   OOOOOOOO XX    XX YY        GGG       EEEEE     NNNN     **</span><br><span class="line">**   OOOOOOOO XX    XX YY        GGG       EEEEE      NN      **</span><br><span class="line">**   OO    OO XXX  XXX YYY   YY  GG GG     EE         NN      **</span><br><span class="line">**   OO    OO  XXXXXX   YYYYYY   GG   GG   EEEEEE     NN      **</span><br><span class="line">**   OO    OO    XX      YYYY    GG    GG  EEEEEE     NN      **</span><br><span class="line">**                                                            **</span><br><span class="line">****************************************************************</span><br><span class="line"> **************************************************************</span><br></pre></td></tr></table></figure>
<p>输入网址<a href="http://www.pythonchallenge.com/pc/def/hockey.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pc/def/hockey.html</a><br>得到：it’s in the air. look at the letters.<br>所以正确答案是氧气oxygen<br>标准答案：</p>
<p><a href="http://www.pythonchallenge.com/pcc/def/oxygen.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/oxygen.html</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge5</title>
    <url>/2020/06/16/python-challenge5/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/peak.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc5-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>网页源代码如下：<br><img src="/image/pc5-2.png"></p>
<p>peak hell的谐音是pickle（一个python的对象序列化模块），需要用pickle对banner.p解析。</p>
<hr>
<p>模块 pickle 实现了对一个 Python 对象结构的二进制序列化和反序列化。 “pickling” 是将 Python 对象及其所拥有的层次结构转化为一个字节流的过程，而 “unpickling” 是相反的操作，会将（来自一个 binary file 或者 bytes-like object 的）字节流转化回一个对象层次结构。 pickling（和 unpickling）也被称为“序列化”, “编组” 1 或者 “平面化”。而为了避免混乱，此处采用术语 “封存 (pickling)” 和 “解封 (unpickling)”。<br>与 json 模块的比较<br>Pickle 协议和 JSON (JavaScript Object Notation) 间有着本质的不同：</p>
<ul>
<li>JSON 是一个文本序列化格式（它输出 unicode 文本，尽管在大多数时候它会接着以 utf-8 编码），而 pickle 是一个二进制序列化格式；</li>
<li>JSON 是我们可以直观阅读的，而 pickle 不是；</li>
<li>JSON是可互操作的，在Python系统之外广泛使用，而pickle则是Python专用的；</li>
<li>默认情况下，JSON 只能表示 Python 内置类型的子集，不能表示自定义的类；但 pickle 可以表示大量的 Python 数据类型（可以合理使用 Python 的对象内省功能自动地表示大多数类型，复杂情况可以通过实现 specific object APIs 来解决）。</li>
<li>不像pickle，对一个不信任的JSON进行反序列化的操作本身不会造成任意代码执行漏洞。</li>
</ul>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from urllib.request import urlopen</span><br><span class="line">import pickle</span><br><span class="line">data &#x3D; pickle.load(urlopen(&quot;http:&#x2F;&#x2F;www.pythonchallenge.com&#x2F;pc&#x2F;def&#x2F;banner.p&quot;))</span><br><span class="line">for line in data:</span><br><span class="line">    print(&quot;&quot;.join([k * v for k, v in line]))</span><br></pre></td></tr></table></figure>
<p>输出结果即为：<br><img src="/image/pc5-3.png"></p>
<p>所以下一个网址是channel<br>标准答案：</p>
<p><a href="http://www.pythonchallenge.com/pcc/def/channel.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/channel.html</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge4</title>
    <url>/2020/06/16/python-challenge4/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/linkedlist.php" target="_blank" rel="noopener">网址</a><br><img src="/image/pc4-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>点击图片转到<a href="http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing=12345" target="_blank" rel="noopener">页面</a>，写有一段文字：and the next nothing is 44827。解该题需要一直更换网址参数nothing，用正则表达式提取每页数字再访问get请求即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import re</span><br><span class="line">key &#x3D; &#39;12345&#39;</span><br><span class="line">base_url &#x3D; &#39;http:&#x2F;&#x2F;www.pythonchallenge.com&#x2F;pc&#x2F;def&#x2F;linkedlist.php?nothing&#x3D;&#39;</span><br><span class="line">url &#x3D; base_url + key</span><br><span class="line">headers &#x3D; &#123;&#39;user-agent&#39;: &#39;my-app&#x2F;0.0.1&#39;&#125;</span><br><span class="line">#flag &#x3D; True</span><br><span class="line">while True:</span><br><span class="line">#    temp &#x3D; key</span><br><span class="line">    r &#x3D; requests.get(url, headers&#x3D;headers)</span><br><span class="line">    s &#x3D; str(r.content, encoding&#x3D;&#39;utf-8&#39;)</span><br><span class="line">    pattern &#x3D; re.compile(&#39;[0-9]+&#39;)</span><br><span class="line">    try:</span><br><span class="line">        key &#x3D; re.findall(pattern, s)[-1]</span><br><span class="line">        url &#x3D; base_url + key</span><br><span class="line">    except:</span><br><span class="line">        break</span><br><span class="line">    print(key)</span><br></pre></td></tr></table></figure>
<p>中间进行到16044时会有如下文字：<br><img src="/image/pc4-2.png"></p>
<p>把16044除以2即可，然后又继续重复以上过程得到<br><img src="/image/pc4-3.png"></p>
<p>得到了<a href="http://www.pythonchallenge.com/pc/def/peak.html" target="_blank" rel="noopener">目标网址</a><br>标准答案：</p>
<p><a href="http://www.pythonchallenge.com/pcc/def/peak.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/peak.html</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge3</title>
    <url>/2020/06/12/python-challenge3/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/equality.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc3-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>hint的意思是一个小字母旁边有三个大字母，网页源代码中又有一堆乱码，用正则表达式把乱码中符合条件的小字母全找出来即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">html &#x3D; urllib.request.urlopen(&quot;http:&#x2F;&#x2F;www.pythonchallenge.com&#x2F;pc&#x2F;def&#x2F;equality.html&quot;).read().decode()</span><br><span class="line">data &#x3D; re.findall(&quot;&lt;!--(.*?)--&gt;&quot;, html, re.DOTALL)[-1]</span><br><span class="line"></span><br><span class="line">pattern &#x3D; re.compile(&#39;[^A-Z]+[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]+&#39;)</span><br><span class="line">list &#x3D; re.findall(pattern,data)</span><br><span class="line">print(&quot;&quot;.join(list))</span><br></pre></td></tr></table></figure>
<p>结果为：linkedlist<br>标准答案：</p>
<p><a href="http://www.pythonchallenge.com/pcc/def/linkedlist.php" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/linkedlist.php</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge2</title>
    <url>/2020/06/09/python-challenge2/</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/ocr.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc2-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>刚看到题目表示一脸懵逼，后来才发现Page Soure指的是网页源代码，如图所示，在网页源代码的注释中部分有一大堆文字：<br><img src="/image/pc2-2.png"></p>
<p>并配有说明：find rare characters in the mess below:</p>
<p>也就是说，我们需要在以下文字中找到出现频率最低的字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">diction &#x3D; &#123;&#125;</span><br><span class="line">for i in list(text):</span><br><span class="line">    if diction.setdefault(i, 1):</span><br><span class="line">        diction[i] +&#x3D; 1</span><br><span class="line"></span><br><span class="line">rare &#x3D; []</span><br><span class="line">rarest &#x3D; 99999999</span><br><span class="line">for key, value in diction.items():</span><br><span class="line">    if value &lt; rarest:</span><br><span class="line">        rarest &#x3D; value</span><br><span class="line">        rare &#x3D; [key]</span><br><span class="line">    elif value &#x3D;&#x3D; rarest:</span><br><span class="line">        rare.append(key)</span><br><span class="line"></span><br><span class="line">print(rare)</span><br></pre></td></tr></table></figure>
<p>标答给出的代码写法更加简便：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &#39;&#39;.join([line.rstrip() for line in text])    </span><br><span class="line">print(s)</span><br><span class="line">OCCURRENCES &#x3D; &#123;&#125;</span><br><span class="line">for c in s: OCCURRENCES[c] &#x3D; OCCURRENCES.get(c, 0) + 1</span><br><span class="line">avgOC &#x3D; len(s) &#x2F;&#x2F; len(OCCURRENCES)</span><br><span class="line">print (&#39;&#39;.join([c for c in s if OCCURRENCES[c] &lt; avgOC]) )</span><br></pre></td></tr></table></figure>
<p>其中rstrip() 删除 string 字符串末尾的指定字符（默认为空格）。<br>结果为：equality<br>标准答案：</p>
<p><a href="http://www.pythonchallenge.com/pcc/def/equality.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/equality.html</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>python challenge1</title>
    <url>/2020/06/09/python-challenge1/</url>
    <content><![CDATA[<p>偶然发现的网站<a href="http://www.pythonchallenge.com/，" target="_blank" rel="noopener">http://www.pythonchallenge.com/，</a><br>网站上有33个python挑战，感觉像猜谜，当游戏玩玩。</p>
<hr>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://www.pythonchallenge.com/pc/def/map.html" target="_blank" rel="noopener">网址</a><br><img src="/image/pc1-1.png"></p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由图片可知题目的意思是把每个字母后移两位，<br>译文为</p>
<p>i hope you didnt translate it by hand.<br>thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long.<br>using string.maketrans() is recommended. now apply on the url.</p>
<p>按网站的原意是要用maketrans函数，网址在<a href="http://www.pythonchallenge.com/pc/def/map.html" target="_blank" rel="noopener">这</a>，所以按规律翻译map即可，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; &quot;g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr&#39;q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.&quot;</span><br><span class="line">before &#x3D; &#39;abcdefghijklmnopqrstuvwxyz&#39;</span><br><span class="line">after &#x3D; &#39;cdefghijklmnopqrstuvwxyzab&#39;</span><br><span class="line">t &#x3D; str.maketrans(before,after)</span><br><span class="line">s &#x3D; s.translate(t)</span><br><span class="line">print(&#39;map&#39;.translate(t))</span><br></pre></td></tr></table></figure>
<hr>
<p>maketrans() 方法用于创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。</p>
<ul>
<li>语法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str.maketrans(intab, outtab)</span><br></pre></td></tr></table></figure></li>
<li>参数：1、intab – 字符串中要替代的字符组成的字符串；2、outtab – 相应的映射字符的字符串。</li>
<li>返回值：返回字符串转换后生成的新字符串。<br>得到结果即为ocr。<br>标准答案：</li>
</ul>
<p><a href="http://www.pythonchallenge.com/pcc/def/ocr.html" target="_blank" rel="noopener">http://www.pythonchallenge.com/pcc/def/ocr.html</a></p>
]]></content>
      <categories>
        <category>python-challenge</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>益智游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>页面淘汰算法</title>
    <url>/2020/04/23/%E9%A1%B5%E9%9D%A2%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h3 id="页面替换策略"><a href="#页面替换策略" class="headerlink" title="页面替换策略"></a>页面替换策略</h3><h4 id="全局页面替换策略"><a href="#全局页面替换策略" class="headerlink" title="全局页面替换策略"></a>全局页面替换策略</h4><ul>
<li><p>最佳页面替换算法OPT<br>选择“将来不再使用的”或“在最远的将来才被访问的”页面被置换。 </p>
</li>
<li><p>先进先出页面替换算法FIFO<br>算法淘汰最先调入内存的页，或者说在内存中驻留时间最长的页。</p>
<blockquote>
<p>存在Belady 异常现象，即缓存页面变大，命中率反而下降。</p>
</blockquote>
</li>
<li><p>最近最少用页面替换算法LRU<br>淘汰使用频率最低的页面。<br>LRU计数法实现即为LFU。</p>
</li>
<li><p>第二次机会页面替换算法SCR<br>检查FIFO中的队首页面(最早进入内存页面)，如果它的“引用位”是0，这个页面既老又没有用，选择该页面淘汰；</p>
</li>
<li><p>时钟页面替换算法Clock<br>实现方式与二次机会置换基本一样，只不过将线形链表构成一个环形链表。</p>
<a id="more"></a>
<h5 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h5><p>在windows环境下编写一个程序，模拟实现OPT,FIFO,LRU等页面淘汰算法,计算“分配不同的页框数”，“页框具有不同的大小”，“不同的指令访问顺序”，“不同淘汰算法”等情形下的命中率。（命中率 = 1-页面失效次数/页地址流长度）。提示：（1）用数组模拟内存；（2）访问并输出数组某个元素即为执行指令；（3）用随机数改变元素的访问顺序，以获得不同的指令流，以便获得不同的局部性。</p>
</li>
<li><p>OPT</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from random import shuffle</span><br><span class="line">class storage(object):</span><br><span class="line"></span><br><span class="line">	def __init__(self, maxlength: int):</span><br><span class="line">		self.maxlength &#x3D; maxlength</span><br><span class="line">		self.curlength &#x3D; 0</span><br><span class="line">		self.list &#x3D; []</span><br><span class="line"></span><br><span class="line">	def run(self, key: int, cur: int):</span><br><span class="line">		print(&quot;访问&quot;, key)</span><br><span class="line">		if key in self.list:</span><br><span class="line">			print(&quot;命中！&quot;)</span><br><span class="line">			print(&quot;now list &#x3D; &quot;, self.list)</span><br><span class="line">		else:</span><br><span class="line">			print(&quot;未命中！&quot;)</span><br><span class="line">			#页面未满</span><br><span class="line">			if self.curlength &lt; self.maxlength:</span><br><span class="line">				self.list.append(key)</span><br><span class="line">				self.curlength +&#x3D; 1</span><br><span class="line">				print(&quot;now list &#x3D; &quot;, self.list)</span><br><span class="line">			#页面满</span><br><span class="line">			else:</span><br><span class="line">				useless &#x3D; []</span><br><span class="line">				#如果存在不会再用到的数，替换并退出</span><br><span class="line">				for i in range(self.maxlength):</span><br><span class="line">					if self.list[i] not in visit[cur: todo]:</span><br><span class="line">						self.list[i] &#x3D; key</span><br><span class="line">						print(&quot;now list &#x3D; &quot;, self.list)</span><br><span class="line">						return</span><br><span class="line">					useless.append(cur)</span><br><span class="line">				#寻找最远的未来用的数</span><br><span class="line">				for i in range(self.maxlength):</span><br><span class="line">					for j in range(cur, todo):</span><br><span class="line">						if self.list[i] &#x3D;&#x3D; visit[j]:</span><br><span class="line">							useless[i] &#x3D; j</span><br><span class="line">							break</span><br><span class="line">				max_position &#x3D; 0</span><br><span class="line">				for i in range(self.maxlength):</span><br><span class="line">					if useless[i] &gt; useless[max_position]:</span><br><span class="line">						max_position &#x3D; i</span><br><span class="line">				self.list[max_position] &#x3D; key</span><br><span class="line">				print(&quot;now list &#x3D; &quot;, self.list)</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:	</span><br><span class="line">	visit &#x3D; [4, 3, 2, 1, 4, 3, 5, 4, 3, 2, 1, 5]</span><br><span class="line">	todo &#x3D; len(visit)</span><br><span class="line">	cur &#x3D; 0</span><br><span class="line">	maxlength &#x3D; 3</span><br><span class="line">	#乱序排列visit</span><br><span class="line">	shuffle(visit)</span><br><span class="line">	print(&quot;待访问数组：&quot;, visit)</span><br><span class="line">	obj &#x3D; storage_opt(maxlength)</span><br><span class="line">	for i in visit:</span><br><span class="line">		obj.run(i, cur)</span><br><span class="line">		cur +&#x3D; 1</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/image/result15.png">
</li>
<li><p>FIFO<br>(以下只贴storage类代码)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class storage(object):</span><br><span class="line"></span><br><span class="line">	def __init__(self, maxlength: int):</span><br><span class="line">		self.maxlength &#x3D; maxlength</span><br><span class="line">		self.curlength &#x3D; 0</span><br><span class="line">		self.list &#x3D; []</span><br><span class="line"></span><br><span class="line">	def run(self, key: int):</span><br><span class="line">		print(&quot;访问&quot;, key)</span><br><span class="line">		if key in self.list:</span><br><span class="line">			print(&quot;命中！&quot;)</span><br><span class="line">			print(&quot;now list &#x3D; &quot;, self.list)</span><br><span class="line">		else:</span><br><span class="line">			print(&quot;未命中！&quot;)</span><br><span class="line">			#页面未满</span><br><span class="line">			if self.curlength &lt; self.maxlength:</span><br><span class="line">				self.list.append(key)</span><br><span class="line">				self.curlength +&#x3D; 1</span><br><span class="line">				print(&quot;now list &#x3D; &quot;, self.list)</span><br><span class="line">			#页面满</span><br><span class="line">			else:</span><br><span class="line">				for i in range(maxlength - 1):</span><br><span class="line">					self.list[-1-i] &#x3D; self.list[-2-i]</span><br><span class="line">				self.list[0] &#x3D; key</span><br><span class="line">				print(&quot;now list &#x3D; &quot;, self.list)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/image/result16.png">
</li>
<li><p>LRU</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class storage(object):</span><br><span class="line"></span><br><span class="line">	def __init__(self, maxlength: int):</span><br><span class="line">		self.maxlength &#x3D; maxlength</span><br><span class="line">		self.curlength &#x3D; 0</span><br><span class="line">		self.list &#x3D; []</span><br><span class="line">		self.R &#x3D; []</span><br><span class="line"></span><br><span class="line">	def run(self, key: int):</span><br><span class="line">		for i in range(self.curlength):</span><br><span class="line">			self.R[i] &#x3D; self.R[i] &lt;&lt; 1</span><br><span class="line">		print(&quot;访问&quot;, key)</span><br><span class="line">		if key in self.list:</span><br><span class="line">			print(&quot;命中！&quot;)</span><br><span class="line">			for i in range(self.curlength):</span><br><span class="line">				if self.list[i] &#x3D;&#x3D; key:</span><br><span class="line">					self.R[i] &#x3D; 1</span><br><span class="line">					break</span><br><span class="line">			print(&quot;now list &#x3D; &quot;, self.list, &quot;R &#x3D; &quot;, self.R)</span><br><span class="line">		else:</span><br><span class="line">			print(&quot;未命中！&quot;)</span><br><span class="line">			#页面未满</span><br><span class="line">			if self.curlength &lt; self.maxlength:</span><br><span class="line">				self.list.append(key)</span><br><span class="line">				self.R.append(1)</span><br><span class="line">				self.curlength +&#x3D; 1</span><br><span class="line">				print(&quot;now list &#x3D; &quot;, self.list, &quot;R &#x3D; &quot;, self.R)</span><br><span class="line">			#页面满</span><br><span class="line">			else:</span><br><span class="line">				max_position &#x3D; 0</span><br><span class="line">				for i in range(self.maxlength):</span><br><span class="line">					if self.R[i] &gt; self.R[max_position]:</span><br><span class="line">						max_position &#x3D; i</span><br><span class="line">				self.list[max_position] &#x3D; key</span><br><span class="line">				self.R[max_position] &#x3D; 1</span><br><span class="line">				print(&quot;now list &#x3D; &quot;, self.list, &quot;R &#x3D; &quot;, self.R)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/image/result17.png">

</li>
</ul>
<hr>
<p>LFU缓存算法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LFUCache:</span><br><span class="line"></span><br><span class="line">    def __init__(self, capacity: int):</span><br><span class="line">        self.capacity &#x3D; capacity</span><br><span class="line">        self.curnums &#x3D; 0</span><br><span class="line">        self.key &#x3D; []</span><br><span class="line">        self.value &#x3D; []</span><br><span class="line">        self.frequnce &#x3D; []</span><br><span class="line">        self.R &#x3D; []</span><br><span class="line"></span><br><span class="line">    def get(self, key: int) -&gt; int:</span><br><span class="line">        for i in range(self.curnums):</span><br><span class="line">            self.R[i] +&#x3D; 1</span><br><span class="line">        for i in range(self.curnums):</span><br><span class="line">            if self.key[i] &#x3D;&#x3D; key:</span><br><span class="line">                self.frequnce[i] +&#x3D; 1</span><br><span class="line">                self.R[i] &#x3D; 1</span><br><span class="line">                return self.value[i]</span><br><span class="line">        return -1</span><br><span class="line"></span><br><span class="line">    def put(self, key: int, value: int) -&gt; None:</span><br><span class="line">        for i in range(self.curnums):</span><br><span class="line">            self.R[i] +&#x3D; 1</span><br><span class="line">        for i in range(self.curnums):</span><br><span class="line">            if self.key[i] &#x3D;&#x3D; key:</span><br><span class="line">                self.value[i] &#x3D; value</span><br><span class="line">                self.frequnce[i] +&#x3D; 1</span><br><span class="line">                return</span><br><span class="line">        if self.curnums &lt; self.capacity:</span><br><span class="line">            self.key.append(key)</span><br><span class="line">            self.value.append(value)</span><br><span class="line">            self.frequnce.append(1)</span><br><span class="line">            self.R.append(1)</span><br><span class="line">            self.curnums +&#x3D; 1</span><br><span class="line">            return</span><br><span class="line">        if self.curnums &gt; 0:</span><br><span class="line">            temp &#x3D; [0]</span><br><span class="line">            for i in range(self.curnums):</span><br><span class="line">                if self.frequnce[i] &lt; self.frequnce[temp[0]]:</span><br><span class="line">                    temp &#x3D; [i]</span><br><span class="line">                elif self.frequnce[i] &#x3D;&#x3D; self.frequnce[temp[0]]:</span><br><span class="line">                    temp.append(i)</span><br><span class="line">            position &#x3D; temp[0]</span><br><span class="line">            for i in temp:</span><br><span class="line">                if self.R[i] &gt; self.R[position]:</span><br><span class="line">                    position &#x3D; i</span><br><span class="line">            self.key[position] &#x3D; key</span><br><span class="line">            self.value[position] &#x3D; value</span><br><span class="line">            self.frequnce[position] &#x3D; 1</span><br><span class="line">            self.R[position] &#x3D; 1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>存储管理</tag>
      </tags>
  </entry>
  <entry>
    <title>创建进程、线程</title>
    <url>/2020/04/02/%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><h4 id="Windows下创建进程"><a href="#Windows下创建进程" class="headerlink" title="Windows下创建进程"></a>Windows下创建进程</h4><p>CreateProcess函数的具体参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BOOL CreateProcess(  </span><br><span class="line">　LPCTSTR lpApplicationName, &#x2F;&#x2F; 应用程序名称  </span><br><span class="line">　LPTSTR lpCommandLine, &#x2F;&#x2F; 命令行字符串  </span><br><span class="line">　LPSECURITY_ATTRIBUTES lpProcessAttributes, &#x2F;&#x2F; 进程的安全属性  </span><br><span class="line">　LPSECURITY_ATTRIBUTES lpThreadAttributes, &#x2F;&#x2F; 线程的安全属性  </span><br><span class="line">　BOOL bInheritHandles, &#x2F;&#x2F; 是否继承父进程的属性  </span><br><span class="line">　DWORD dwCreationFlags, &#x2F;&#x2F; 创建标志  </span><br><span class="line">　LPVOID lpEnvironment, &#x2F;&#x2F; 指向新的环境块的指针  </span><br><span class="line">　LPCTSTR lpCurrentDirectory, &#x2F;&#x2F; 指向当前目录名的指针  </span><br><span class="line">　LPSTARTUPINFO lpStartupInfo, &#x2F;&#x2F; 传递给新进程的信息  </span><br><span class="line">　LPPROCESS_INFORMATION lpProcessInformation &#x2F;&#x2F; 新进程返回的信息  </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#define LINE 1024</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	STARTUPINFO si &#x3D; &#123; sizeof(si) &#125;;</span><br><span class="line">	PROCESS_INFORMATION pi;</span><br><span class="line"></span><br><span class="line">	const char* filename &#x3D; &quot;C:\\Windows\\system32\\notepad.exe&quot;;</span><br><span class="line">	TCHAR command[LINE];</span><br><span class="line">	MultiByteToWideChar(CP_ACP, 0, filename, -1, command, LINE);</span><br><span class="line">	::CreateProcess(NULL, command, NULL, NULL, FALSE,</span><br><span class="line">		CREATE_NEW_CONSOLE, NULL, NULL, &amp;si, &amp;pi);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过该段程序可以启动记事本。</p>
<h4 id="Windows下创建线程"><a href="#Windows下创建线程" class="headerlink" title="Windows下创建线程"></a>Windows下创建线程</h4><p>CreateThread函数的具体参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HANDLE WINAPI CreateThread(</span><br><span class="line">	  _In_opt_  LPSECURITY_ATTRIBUTES  lpThreadAttributes,   </span><br><span class="line">	  _In_      SIZE_T                 dwStackSize,</span><br><span class="line">	  _In_      LPTHREAD_START_ROUTINE lpStartAddress,</span><br><span class="line">	  _In_opt_  LPVOID                 lpParameter,</span><br><span class="line">	  _In_      DWORD                  dwCreationFlags,</span><br><span class="line">	  _Out_opt_ LPDWORD                lpThreadId</span><br><span class="line">	);</span><br></pre></td></tr></table></figure>
<p>第一个参数 lpThreadAttributes 表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。<br>第二个参数 dwStackSize 表示线程栈空间大小。传入0表示使用默认大小（1MB）。<br>第三个参数 lpStartAddress 表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。<br>第四个参数 lpParameter 是传给线程函数的参数。<br>第五个参数 dwCreationFlags 指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。<br>第六个参数 lpThreadId 将返回线程的ID号，传入NULL表示不需要返回该线程ID号。</p>
<blockquote>
<p>现在一般用_beginthreadex()函数更安全地创建线程。</p>
</blockquote>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include&lt;Windows.h&gt;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI FatherThreadFunc(LPVOID) &#123;</span><br><span class="line">	printf(&quot;This is father Thread, pid&#x3D;%d\n&quot;, GetCurrentThreadId());</span><br><span class="line">	for (int i &#x3D; 0; i &lt; 1000; i++) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, i);</span><br><span class="line">		Sleep(500);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DWORD WINAPI SonThreadFunc(LPVOID) &#123;</span><br><span class="line">	printf(&quot;This is son Thread, pid&#x3D;%d\n&quot;, GetCurrentThreadId());</span><br><span class="line">	for (int i &#x3D; 1000; i &gt; 0; i--) &#123;</span><br><span class="line">		printf(&quot;%d\n&quot;, i);</span><br><span class="line">		Sleep(500);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hThread[2];</span><br><span class="line">	DWORD ThreadID;</span><br><span class="line"></span><br><span class="line">	if ((hThread[0] &#x3D; CreateThread(NULL, 0, FatherThreadFunc, 0, 0, &amp;ThreadID)) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		printf(&quot;create error!\n&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">	if ((hThread[1] &#x3D; CreateThread(NULL, 0, SonThreadFunc, 0, 0, &amp;ThreadID)) &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">		printf(&quot;create error!\n&quot;);</span><br><span class="line">	&#125;;</span><br><span class="line">	WaitForMultipleObjects(2, hThread, TRUE, INFINITE);</span><br><span class="line">	CloseHandle(hThread[0]);</span><br><span class="line">	CloseHandle(hThread[1]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里演示了创建两个线程，一个从1数到1000，一个从1000数到1。</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h4 id="Linux创建进程"><a href="#Linux创建进程" class="headerlink" title="Linux创建进程"></a>Linux创建进程</h4><p>父进程通过fork()来创建子进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;先输出该进程的进程号</span><br><span class="line">    fprintf(stdout,&quot;I am the first process,my pid is %d,my parent pid is %d\n&quot;,getpid(),getppid());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建进程</span><br><span class="line">    pid_t pid;</span><br><span class="line">    if((pid&#x3D;fork())&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;如果进程创建失败</span><br><span class="line">        fprintf(stderr,&quot;fork failed!&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid&#x3D;&#x3D;0)&#x2F;&#x2F;子进程fork()返回值为0</span><br><span class="line">        fprintf(stdout,&quot;I am the child process,my pid is %d,my parent pid is %d\n&quot;,getpid(),getppid());</span><br><span class="line">    else&#x2F;&#x2F;父进程fork()返回值为子进程进程号</span><br><span class="line">        fprintf(stdout,&quot;I am the parent process,my pid is %d,my child pid is %d,my parent pid is %d\n&quot;,getpid(),pid,getppid());</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/image/sendpix0.jpg"></p>
<h4 id="Linux创建线程"><a href="#Linux创建线程" class="headerlink" title="Linux创建线程"></a>Linux创建线程</h4><p>代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">static void* pthread_1(void *pVoid)&#123;</span><br><span class="line">    for(int i &#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, i);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">static void* pthread_2(void *pVoid)&#123;</span><br><span class="line">    for(int i &#x3D;0; i&lt;1000; i++)&#123;</span><br><span class="line">        printf(&quot;%d\n&quot;, 1000-i);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    pthread_t tips_1;</span><br><span class="line">    pthread_t tips_2;</span><br><span class="line">    if((pthread_create(&amp;tips_1,NULL,pthread_1,NULL))!&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr,&quot;thread_1 failed!&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	if((pthread_create(&amp;tips_2,NULL,pthread_2,NULL))!&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr,&quot;thread_2 failed!&quot;);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">    void *result1;</span><br><span class="line">    void *result2;</span><br><span class="line"></span><br><span class="line">    pthread_join(tips_1, &amp;result1);</span><br><span class="line">    pthread_join(tips_2, &amp;result2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br>效果与Windows下的一样<br><img src="/image/sendpix1.jpg"></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>进程控制</tag>
        <tag>线程控制</tag>
      </tags>
  </entry>
  <entry>
    <title>卡牌分组</title>
    <url>/2020/03/28/%E5%8D%A1%E7%89%8C%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/x-of-a-kind-in-a-deck-of-cards/solution/qia-pai-fen-zu-by-leetcode-solution/" target="_blank" rel="noopener">原题链接</a><br>collections.Counter统计字符串（数字）种类及数量，返回字典；</p>
<p>functools.reduce逐次对上次函数结果与当前序列元素应用函数；</p>
<ul>
<li>reduce(function, sequence)</li>
<li>例如 reduce(lambda x, y: x+y, [1, 2, 3, 4, 5]) 计算为((((1+2)+3)+4)+5)</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>最大公约数</tag>
      </tags>
  </entry>
  <entry>
    <title>水壶问题（Die Hard）</title>
    <url>/2020/03/24/%E6%B0%B4%E5%A3%B6%E9%97%AE%E9%A2%98%EF%BC%88Die-Hard%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/water-and-jug-problem/" target="_blank" rel="noopener">原题链接</a></p>
<ul>
<li>深度优先搜索算法<br>用(remain_x,remain_y)记录当前状态，当所有状态都被遍历时就能得到结果。<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canMeasureWater(self, x: int, y: int, z: int) -&gt; bool:</span><br><span class="line">        stack &#x3D; [(0, 0)]</span><br><span class="line">        self.seen &#x3D; set()</span><br><span class="line">        while stack:</span><br><span class="line">            remain_x, remain_y &#x3D; stack.pop()</span><br><span class="line">            if remain_x &#x3D;&#x3D; z or remain_y &#x3D;&#x3D; z or remain_x + remain_y &#x3D;&#x3D; z:</span><br><span class="line">                return True</span><br><span class="line">            if (remain_x, remain_y) in self.seen:</span><br><span class="line">                continue</span><br><span class="line">            self.seen.add((remain_x, remain_y))</span><br><span class="line">            # 把 X 壶灌满。</span><br><span class="line">            stack.append((x, remain_y))</span><br><span class="line">            # 把 Y 壶灌满。</span><br><span class="line">            stack.append((remain_x, y))</span><br><span class="line">            # 把 X 壶倒空。</span><br><span class="line">            stack.append((0, remain_y))</span><br><span class="line">            # 把 Y 壶倒空。</span><br><span class="line">            stack.append((remain_x, 0))</span><br><span class="line">            # 把 X 壶的水灌进 Y 壶，直至灌满或倒空。</span><br><span class="line">            stack.append((remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y)))</span><br><span class="line">            # 把 Y 壶的水灌进 X 壶，直至灌满或倒空。</span><br><span class="line">            stack.append((remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x)))</span><br><span class="line">        return False</span><br></pre></td></tr></table></figure></li>
<li>数学方法<br>因为装满或者倒出不满的水壶没有意义，所以每次操作必定是有$x$或$y$升水的变化，即$ax+by=z$，贝祖定理告诉我们，$ax+by=z$有解当且仅当$z$是$x,y$的最大公约数的倍数。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def canMeasureWater(self, x: int, y: int, z: int) -&gt; bool:</span><br><span class="line">        if x + y &lt; z:</span><br><span class="line">            return False</span><br><span class="line">        if x &#x3D;&#x3D; 0 or y &#x3D;&#x3D; 0:</span><br><span class="line">            return z &#x3D;&#x3D; 0 or x + y &#x3D;&#x3D; z</span><br><span class="line">        return z % math.gcd(x, y) &#x3D;&#x3D; 0</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>指纹识别处理（一）--预处理</title>
    <url>/2020/03/24/%E6%8C%87%E7%BA%B9%E8%AF%86%E5%88%AB%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89--%E9%A2%84%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h4 id="图像的归一化"><a href="#图像的归一化" class="headerlink" title="图像的归一化"></a>图像的归一化</h4><p>指纹图像的归一化的目的是使得图像灰度值达到一个预先定义的平均值和方差，增强图像整体对比度。归一化处理能够有效地解决按压不均匀对采集到的指纹图像的影响。<br>$$<br>g(x,y) = \left{ \begin{array}{ll}<br>    m_0+\sqrt{\frac{v_0(I(x,y)-m)^2}{v}} &amp; \textrm{if $g(x,y)\geq m$}\<br>    m_0-\sqrt{\frac{v_0(I(x,y)-m)^2}{v}} &amp; \textrm{if $g(x,y)&lt;m$}<br>    \end{array} \right.<br>$$<br>其中$m,v$分别为图像的均值和方差，$m_0,v_0$为指定的方差和均值</p>
<a id="more"></a>
<h5 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image &#x3D; imread(&#39;F1.jpg&#39;);</span><br><span class="line">[row, cloumn] &#x3D; size(image);</span><br><span class="line">dimage &#x3D; double(image);</span><br><span class="line">mean &#x3D; mean(mean(dimage));</span><br><span class="line">sigma &#x3D; std2(dimage);</span><br><span class="line">m0 &#x3D; 100; %期望的均值</span><br><span class="line">s0 &#x3D; 2000; %期望的方差</span><br><span class="line">for x&#x3D;1:row</span><br><span class="line">    for y&#x3D;1:cloumn</span><br><span class="line">        if dimage(x,y)&gt; mean</span><br><span class="line">            dimage(x,y)&#x3D;m0+sqrt(s0*(dimage(x,y)-mean)&#x2F;sigma);</span><br><span class="line">        else</span><br><span class="line">            dimage(x,y)&#x3D;m0-sqrt(s0*(mean-dimage(x,y))&#x2F;sigma);</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">figure,imshow(uint8(dimage))</span><br></pre></td></tr></table></figure>
<h5 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h5><p>原图：<br><img src="/image/F1.png"><br>归一化后的图：<br><img src="/image/guiyi1.png"></p>
<p>作频谱图可以发现被滤去的频率：<br><img src="/image/pinpu1.png"></p>
<p>参考资料：<br>[1]<a href="https://wenku.baidu.com/view/9a30a721d5d8d15abe23482fb4daa58da0111c82.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/9a30a721d5d8d15abe23482fb4daa58da0111c82.html</a><br>[2]<a href="https://blog.csdn.net/MrCharles/article/details/79292496" target="_blank" rel="noopener">https://blog.csdn.net/MrCharles/article/details/79292496</a></p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>指纹识别</tag>
      </tags>
  </entry>
  <entry>
    <title>WinDump抓包</title>
    <url>/2020/03/22/WinDump%E6%8A%93%E5%8C%85/</url>
    <content><![CDATA[<h3 id="安装WinDump"><a href="#安装WinDump" class="headerlink" title="安装WinDump"></a>安装WinDump</h3><ol>
<li>请先安装WinPcap</li>
<li>将windump置于某个目录下，比如D盘根目录。无需安装。</li>
<li>可选：把windump所在目录添加到系统变量Path</li>
<li>请打开命令行窗口，执行windump，即可体验抓包。请不要通过双击windump图标来启动windump</li>
</ol>
<h3 id="抓取对百度的请求"><a href="#抓取对百度的请求" class="headerlink" title="抓取对百度的请求"></a>抓取对百度的请求</h3><ol>
<li><p>找到本机的网卡，使用WinDump -D指令（用管理员身份打开）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WinDump -D</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<img src="/image/operation1.png">
</li>
<li><p>指定网卡抓取icmp报文</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windump -i 4 icmp</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一终端中发送Ping请求</p>
<img src="/image/operation2.png">
</li>
<li><p>抓取到包</p>
<img src="/image/operation3.png"></li>
</ol>
]]></content>
      <categories>
        <category>网络信息安全</category>
      </categories>
      <tags>
        <tag>网络抓包分析</tag>
      </tags>
  </entry>
  <entry>
    <title>第181场周赛</title>
    <url>/2020/03/22/%E7%AC%AC181%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/create-target-array-in-the-given-order/" target="_blank" rel="noopener">按既定顺序创建目标数组</a><br>送分题，就嗯加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def createTargetArray(self, nums: List[int], index: List[int]) -&gt; List[int]:</span><br><span class="line">        target &#x3D; []</span><br><span class="line">        for i in range(0, len(nums)):</span><br><span class="line">            target &#x3D; target[0:index[i]] + [nums[i]] + target[index[i]:len(target)]</span><br><span class="line">        return target</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/four-divisors/" target="_blank" rel="noopener">四因数</a><br>没什么好说的</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">class Solution:</span><br><span class="line">    def sumFourDivisors(self, nums: List[int]) -&gt; int:</span><br><span class="line">        all_sum &#x3D; 0</span><br><span class="line">        for i in nums:</span><br><span class="line">            temp &#x3D; []</span><br><span class="line">            for j in range(1, int(math.sqrt(i))+1):</span><br><span class="line">                if i % j &#x3D;&#x3D; 0:</span><br><span class="line">                    temp.append(j)</span><br><span class="line">                    if i &#x2F; j !&#x3D; j:</span><br><span class="line">                        temp.append(i&#x2F;j)</span><br><span class="line">            if len(temp) &#x3D;&#x3D; 4:</span><br><span class="line">                all_sum +&#x3D; sum(temp)</span><br><span class="line">        return int(all_sum)</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/check-if-there-is-a-valid-path-in-a-grid/" target="_blank" rel="noopener">检查网格中是否存在有效路径</a><br>这题目算了好久，还是有细节漏掉了，通过65/75<br>leetcode里函数要放到解题函数里面，不能并列，浪费好多时间<br>应该是用dfs解答，但是关于树和图的算法我基本上都忘了<br>错误代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    def hasValidPath(self, grid: List[List[int]]) -&gt; bool:</span><br><span class="line">        cur &#x3D; [0,0]</span><br><span class="line">        prev &#x3D; []</span><br><span class="line">        if not grid:</span><br><span class="line">            return False</span><br><span class="line">        def findPath(cur:List[int],prev:List[int],grid: List[List[int]]) -&gt; bool:</span><br><span class="line">            m &#x3D; len(grid)-1</span><br><span class="line">            n &#x3D; len(grid[0]) - 1</span><br><span class="line">            while cur !&#x3D; [m, n]:</span><br><span class="line">                if prev:</span><br><span class="line">                    if prev[0] &#x3D;&#x3D; cur[0]:</span><br><span class="line">                        if prev[1] - cur[1] &#x3D;&#x3D; 1:</span><br><span class="line">                            if grid[prev[0]][prev[1]] in [2, 4, 6] or grid[cur[0]][cur[1]] in [2, 3, 5]:</span><br><span class="line">                                return False</span><br><span class="line">                        else:</span><br><span class="line">                            if grid[prev[0]][prev[1]] in [2, 3, 5] or grid[cur[0]][cur[1]] in [2, 4, 6]:</span><br><span class="line">                                return False</span><br><span class="line">                    elif prev[1] &#x3D;&#x3D; cur[1]:</span><br><span class="line">                        if prev[0] - cur[0] &#x3D;&#x3D; 1:</span><br><span class="line">                            if grid[prev[0]][prev[1]] in [1, 3, 4] or grid[cur[0]][cur[1]] in [1, 5, 6]:</span><br><span class="line">                                return False</span><br><span class="line">                        else:</span><br><span class="line">                            if grid[prev[0]][prev[1]] in [1, 5, 6] or grid[cur[0]][cur[1]] in [1, 3, 4]:</span><br><span class="line">                                return False</span><br><span class="line">                if grid[cur[0]][cur[1]] &#x3D;&#x3D; 1:</span><br><span class="line">                    if prev:</span><br><span class="line">                        if prev[1] &gt; cur[1]:</span><br><span class="line">                            if cur[1]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0],cur[1] - 1]</span><br><span class="line">                        else:</span><br><span class="line">                            if cur[1]&gt;n-1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0],cur[1] + 1]</span><br><span class="line">                    else:</span><br><span class="line">                        prev &#x3D; [0, 0]</span><br><span class="line">                        if n&gt;0:</span><br><span class="line">                            cur &#x3D; [0, 1]</span><br><span class="line">                        else:</span><br><span class="line">                            return False</span><br><span class="line">                elif grid[cur[0]][cur[1]] &#x3D;&#x3D; 2:</span><br><span class="line">                    if prev:</span><br><span class="line">                        if prev[0] &gt; cur[0]:</span><br><span class="line">                            if cur[0]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0] - 1,cur[1]]</span><br><span class="line">                        else:</span><br><span class="line">                            if cur[0]&gt;m-1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0] + 1,cur[1]]</span><br><span class="line">                    else:</span><br><span class="line">                        prev &#x3D; [0, 0]</span><br><span class="line">                        if m&gt;0:</span><br><span class="line">                            cur &#x3D; [1, 0]</span><br><span class="line">                        else:</span><br><span class="line">                            return False</span><br><span class="line">                elif grid[cur[0]][cur[1]] &#x3D;&#x3D; 3:</span><br><span class="line">                    if prev:</span><br><span class="line">                        if prev[1] &lt; cur[1]:</span><br><span class="line">                            if cur[0]&gt;m-1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0] + 1,cur[1]]</span><br><span class="line">                        else:</span><br><span class="line">                            if cur[1]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0],cur[1] - 1]</span><br><span class="line">                    else:</span><br><span class="line">                        prev &#x3D; [0, 0]</span><br><span class="line">                        if m&gt;0:</span><br><span class="line">                            cur &#x3D; [1, 0]</span><br><span class="line">                        else:</span><br><span class="line">                            return False</span><br><span class="line">                elif grid[cur[0]][cur[1]] &#x3D;&#x3D; 5:</span><br><span class="line">                    if prev:</span><br><span class="line">                        if prev[1] &lt; cur[1]:</span><br><span class="line">                            if cur[0]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0] - 1,cur[1]]</span><br><span class="line">                        else:</span><br><span class="line">                            if cur[1]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0],cur[1] - 1]</span><br><span class="line">                    else:</span><br><span class="line">                        return False</span><br><span class="line">                elif grid[cur[0]][cur[1]] &#x3D;&#x3D; 6:</span><br><span class="line">                    if prev:</span><br><span class="line">                        if prev[1] &gt; cur[1]:</span><br><span class="line">                            if cur[0]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0] - 1,cur[1]]</span><br><span class="line">                        else:</span><br><span class="line">                            if cur[1]&gt;n-1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0],cur[1] + 1]</span><br><span class="line">                    else:</span><br><span class="line">                        prev &#x3D; [0, 0]</span><br><span class="line">                        if n&gt;0:</span><br><span class="line">                            cur &#x3D; [0, 1]</span><br><span class="line">                        else:</span><br><span class="line">                            return False</span><br><span class="line">                elif grid[cur[0]][cur[1]] &#x3D;&#x3D; 4:</span><br><span class="line">                    if prev:</span><br><span class="line">                        if prev[1] &gt; cur[1]:</span><br><span class="line">                            if cur[0]&lt;1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0] - 1,cur[1]]</span><br><span class="line">                        else:</span><br><span class="line">                            if cur[1]&gt;n-1:</span><br><span class="line">                                return False</span><br><span class="line">                            prev &#x3D; cur</span><br><span class="line">                            cur &#x3D; [cur[0],cur[1] + 1]</span><br><span class="line">                    else:</span><br><span class="line">                        prev &#x3D; [0, 0]</span><br><span class="line">                        temp &#x3D; 0</span><br><span class="line">                        if n&gt;0:</span><br><span class="line">                            cur &#x3D; [0, 1]</span><br><span class="line">                            temp &#x3D; findPath(cur,prev,grid)</span><br><span class="line">                            if temp:</span><br><span class="line">                                return True</span><br><span class="line">                            else:</span><br><span class="line">                                if m&gt;0:</span><br><span class="line">                                    cur &#x3D; [1,0]</span><br><span class="line">                                    temp &#x3D; findPath(cur,prev,grid)</span><br><span class="line">                                    if temp:</span><br><span class="line">                                        return True</span><br><span class="line">                                    else:</span><br><span class="line">                                        return False</span><br><span class="line">                        else:</span><br><span class="line">                            return False</span><br><span class="line">            if prev:</span><br><span class="line">                if prev[0] &#x3D;&#x3D; cur[0]:</span><br><span class="line">                    if prev[1] - cur[1] &#x3D;&#x3D; 1:</span><br><span class="line">                        if grid[prev[0]][prev[1]] in [2, 4, 6] or grid[cur[0]][cur[1]] in [2, 3, 5]:</span><br><span class="line">                            return False</span><br><span class="line">                    else:</span><br><span class="line">                        if grid[prev[0]][prev[1]] in [2, 3, 5] or grid[cur[0]][cur[1]] in [2, 4, 6]:</span><br><span class="line">                            return False</span><br><span class="line">                elif prev[1] &#x3D;&#x3D; cur[1]:</span><br><span class="line">                    if prev[0] - cur[0] &#x3D;&#x3D; 1:</span><br><span class="line">                        if grid[prev[0]][prev[1]] in [1, 3, 4] or grid[cur[0]][cur[1]] in [1, 5, 6]:</span><br><span class="line">                            return False</span><br><span class="line">                    else:</span><br><span class="line">                        if grid[prev[0]][prev[1]] in [1, 5, 6] or grid[cur[0]][cur[1]] in [1, 3, 4]:</span><br><span class="line">                            return False</span><br><span class="line">            return True</span><br><span class="line">        return findPath(cur,prev,grid)</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/longest-happy-prefix/" target="_blank" rel="noopener">最长快乐前缀</a><br>这题目太可惜了，本以为是困难题没看，结果事后用python做一下子就ac了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def longestPrefix(self, s: str) -&gt; str:</span><br><span class="line">        for j in range(1, len(s)+1):</span><br><span class="line">            i &#x3D; len(s) - j</span><br><span class="line">            if s[len(s)-i:len(s)] &#x3D;&#x3D; s[:i]:</span><br><span class="line">                return s[:i]</span><br><span class="line">        return &quot;&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>第180场周赛</title>
    <url>/2020/03/15/%E7%AC%AC180%E5%9C%BA%E5%91%A8%E8%B5%9B/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/" target="_blank" rel="noopener">矩阵中的幸运数</a><br>没事做来第一次尝试周赛题，此题感觉似曾相识，直接嗯算AC了，时间复杂度$O(n^2)$，改进空间还挺大，$O(n^2)$的循环用了两次，空间占用也挺多。</p>
<a id="more"></a>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def luckyNumbers (self, matrix: List[List[int]]) -&gt; List[int]:</span><br><span class="line">        m &#x3D; len(matrix)</span><br><span class="line">        if m &#x3D;&#x3D; 0:</span><br><span class="line">            return []</span><br><span class="line">        n &#x3D; len(matrix[0])</span><br><span class="line">        output &#x3D; []</span><br><span class="line">        min_val &#x3D; []</span><br><span class="line">        min_col &#x3D; []</span><br><span class="line">        for row in matrix:</span><br><span class="line">            temp_val &#x3D; row[0]</span><br><span class="line">            temp_col &#x3D; 0</span><br><span class="line">            for i in range(0, n):</span><br><span class="line">                if row[i] &lt; temp_val:</span><br><span class="line">                    temp_val &#x3D; row[i]</span><br><span class="line">                    temp_col &#x3D; i</span><br><span class="line">            min_val.append(temp_val)</span><br><span class="line">            min_col.append(temp_col)</span><br><span class="line">        while min_col:</span><br><span class="line">            col &#x3D; min_col.pop()</span><br><span class="line">            val &#x3D; min_val.pop()</span><br><span class="line">            flag &#x3D; 1</span><br><span class="line">            for row in matrix:</span><br><span class="line">                if row[col] &gt; val:</span><br><span class="line">                    flag &#x3D; 0</span><br><span class="line">                    break </span><br><span class="line">            if flag:</span><br><span class="line">                output.append(val)</span><br><span class="line">        return output</span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/" target="_blank" rel="noopener"> 设计一个支持增量操作的栈</a><br>关键在于增量的实现：将增量值记录在第k个元素上而不是每次新增都遍历。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CustomStack:</span><br><span class="line"></span><br><span class="line">    def __init__(self, maxSize: int):</span><br><span class="line">        self.s &#x3D; []</span><br><span class="line">        self.size &#x3D; 0</span><br><span class="line">        self.maxSize &#x3D; maxSize</span><br><span class="line"></span><br><span class="line">    def push(self, x: int) -&gt; None:</span><br><span class="line">        if self.size &lt; self.maxSize:</span><br><span class="line">            self.size +&#x3D; 1</span><br><span class="line">            self.s.append([x, 0])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def pop(self) -&gt; int:</span><br><span class="line">        if self.size &gt; 0:</span><br><span class="line">            self.size -&#x3D; 1</span><br><span class="line">            x, inc &#x3D; self.s.pop()</span><br><span class="line">            if self.size &gt; 0:</span><br><span class="line">                self.s[-1][1] +&#x3D; inc</span><br><span class="line">            return x + inc</span><br><span class="line">        else:</span><br><span class="line">            return -1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def increment(self, k: int, val: int) -&gt; None:</span><br><span class="line">        if self.size &gt; 0:</span><br><span class="line">            k &#x3D; min(k - 1, self.size - 1)</span><br><span class="line">            self.s[k][1] +&#x3D; val</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener">将二叉搜索树变平衡</a><br>经典数据结构题，有空补。</p>
<p><a href="https://leetcode-cn.com/problems/maximum-performance-of-a-team/" target="_blank" rel="noopener">最大的团队表现值</a><br>似乎有点难，有空补。</p>
<blockquote>
<p> 前三题都挺基础的，以后每周都可以做一下，当个目标。</p>
</blockquote>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>同态滤波</title>
    <url>/2020/03/14/%E5%90%8C%E6%80%81%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h3 id="作频谱图"><a href="#作频谱图" class="headerlink" title="作频谱图"></a>作频谱图</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; imread(&#39;fig4.jpg&#39;);</span><br><span class="line">%二维傅里叶变换</span><br><span class="line">Y &#x3D; fft2(f);</span><br><span class="line">%频谱偏移</span><br><span class="line">y1 &#x3D; abs(fftshift(Y));</span><br><span class="line">%归一化处理</span><br><span class="line">g &#x3D; (y1 - min(min(y1)))&#x2F;(max(max(y1))-min(min(y1)))*255;</span><br><span class="line">subplot(2,1,1);imshow(f),title(&#39;原图像&#39;);</span><br><span class="line">subplot(2,1,2);imshow(g),title(&#39;频谱图&#39;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><img src="/image/result13.png">

<h3 id="同态滤波"><a href="#同态滤波" class="headerlink" title="同态滤波"></a>同态滤波</h3><p><a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/OWENS/LECT5/node4.html" target="_blank" rel="noopener">滤波原理</a></p>
<h4 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h4><p>先对原函数取对数，做傅里叶变换后通过如下滤波器：<br><img src="/image/formula1.png"></p>
<p>再做逆变换取指数。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; rgb2gray(imread(&#39;fig6.jpg&#39;));</span><br><span class="line">[row, cloumn] &#x3D; size(f);</span><br><span class="line">g &#x3D; log(im2double(f)*255+1);</span><br><span class="line">%二维傅里叶变换</span><br><span class="line">Y &#x3D; fft2(g); </span><br><span class="line">rL&#x3D;0.2;    </span><br><span class="line">rH&#x3D;0.5;</span><br><span class="line">c&#x3D;2;    </span><br><span class="line">d0&#x3D;80;  </span><br><span class="line">n1&#x3D;floor(row&#x2F;2);    </span><br><span class="line">n2&#x3D;floor(cloumn&#x2F;2);    </span><br><span class="line">for i&#x3D;1:row    </span><br><span class="line">    for j&#x3D;1:cloumn    </span><br><span class="line">        D(i,j)&#x3D;((i-n1).^2+(j-n2).^2);    </span><br><span class="line">        H(i,j)&#x3D;(rH-rL).*(1-exp(c.*(-D(i,j).&#x2F;(d0^2))))+rL; </span><br><span class="line">    end    </span><br><span class="line">end    </span><br><span class="line"></span><br><span class="line">I2&#x3D;real(ifft2(H.*Y)); </span><br><span class="line">I3&#x3D;exp(I2)-1; </span><br><span class="line">subplot(2,1,1);imshow(f),title(&#39;原图像&#39;);</span><br><span class="line">subplot(2,1,2);imshow(I3,[]),title(&#39;同态滤波后图&#39;)</span><br></pre></td></tr></table></figure>
<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><img src="/image/result14.png">]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>频域上的处理</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列</title>
    <url>/2020/03/14/%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">原题链接</a></p>
<ul>
<li>动态规划<br>这个比较容易想到，复杂度也比较高$O(n^2)$，直接贴代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">  def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">      if not nums:</span><br><span class="line">          return 0</span><br><span class="line">      dp &#x3D; []</span><br><span class="line">      for i in range(len(nums)):</span><br><span class="line">          dp.append(1)</span><br><span class="line">          for j in range(i):</span><br><span class="line">              if nums[i] &gt; nums[j]:</span><br><span class="line">                  dp[i] &#x3D; max(dp[i], dp[j] + 1)</span><br><span class="line">      return max(dp)</span><br></pre></td></tr></table></figure></li>
<li>贪心 + 二分<br>用数组ｄ[max_length]记录长度为i的子序列的末尾元素d[i]，为了让子序列尽可能长，每个末尾元素就应该尽可能小；遍历一遍数组，大的加入末尾，增加数组d[]的长度，小的插入中间（如果ｄ中有相同元素就不能插入），这里的插入用二分查找能减少复杂度，但是我懒得用了。<br>代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLIS(self, nums: List[int]) -&gt; int:</span><br><span class="line">        if len(nums) &#x3D;&#x3D; 0:</span><br><span class="line">            return 0</span><br><span class="line">        d &#x3D; [0, nums[0]]</span><br><span class="line">        max_length &#x3D; 1</span><br><span class="line">        for i in range(1, len(nums)):</span><br><span class="line">            if nums[i] &gt; d[max_length]:</span><br><span class="line">                max_length +&#x3D; 1</span><br><span class="line">                d.append(nums[i])</span><br><span class="line">            else:</span><br><span class="line">                for j in range(1, max_length + 1):</span><br><span class="line">                    if nums[i] &#x3D;&#x3D; d[j]:</span><br><span class="line">                        break</span><br><span class="line">                    elif nums[i] &lt; d[j]:</span><br><span class="line">                        d[j] &#x3D; nums[i]</span><br><span class="line">                        break</span><br><span class="line">        return max_length</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
        <tag>贪心算法</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>多数元素</title>
    <url>/2020/03/14/%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>cnt计数，遇到相同的数加一，不同的就减一，减到０换下一个数开始计数；最后剩下的ret就是结果。<br>因为多数元素比[n/2]还多，这样计数相当于一次兑掉两个不同的元素，剩下的就是结果。</p>
<hr>
<p>在python里直接排序取中位数就可以了。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def majorityElement(self, nums: List[int]) -&gt; int:</span><br><span class="line">        cnt, ret &#x3D; 0, 0</span><br><span class="line">        for num in nums:</span><br><span class="line">            if cnt &#x3D;&#x3D; 0:</span><br><span class="line">                ret &#x3D; num</span><br><span class="line">            if num !&#x3D; ret:</span><br><span class="line">                cnt -&#x3D; 1</span><br><span class="line">            else:</span><br><span class="line">                cnt +&#x3D; 1</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>
<h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3><ul>
<li>时间复杂度：$O(n)$</li>
<li>算法复杂度：$O(1)$</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串的最大公因子</title>
    <url>/2020/03/12/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E5%AD%90/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/greatest-common-divisor-of-strings/" target="_blank" rel="noopener">原题链接</a></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>先用<a href="https://baike.baidu.com/item/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/1647675?fromtitle=%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B3%95&fromid=4625352&fr=aladdin" target="_blank" rel="noopener">辗转相除法</a>求出字符串长度的最大公因子，<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def gcd(a, b):</span><br><span class="line">  while a !&#x3D; 0:</span><br><span class="line">      a, b &#x3D; b % a, a </span><br><span class="line">  return b</span><br></pre></td></tr></table></figure>
然后我发现原来python的math里本来就有gcd函数。。。</li>
<li>判断两个字符串正反相加是否相等<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>import math
class Solution:
  def gcdOfStrings(self, str1: str, str2: str) -&gt; str:
      ans_len = math.gcd(len(str1),len( str2))
      ans = str1[: ans_len]
      if str1 + str2 == str2 + str1:
          return ans
      return &quot;&quot;</code></pre><h3 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h3></li>
<li>时间复杂度：字符串的拼接比较需要$O(n)$，最大公因子的计算需要$O(log n)$，总时间复杂度为$O(n)$</li>
<li>空间复杂度：$O(n)$来存放$str1+str2$</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>字符串</tag>
        <tag>辗转相除法</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的Linux命令(一)--文件命令</title>
    <url>/2020/03/12/%E5%B8%B8%E8%A7%81%E7%9A%84Linux%E5%91%BD%E4%BB%A4(%E4%B8%80)--%E6%96%87%E4%BB%B6%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><ul>
<li>命名英文原意：list</li>
<li>功能：显示目录文件</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [选项]... [文件]...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-a, –all            不隐藏任何以. 开始的项目<br>-A, –almost-all        列出除. 及.. 以外的任何项目<br>–author            与-l 同时使用时列出每个文件的作者<br>-b, –escape            以八进制溢出序列表示不可打印的字符<br> -l                使用较长格式列出信息<br>  -r, –reverse            逆序排列<br>  -R, –recursive        递归显示子目录<br>  -s, –size            以块数形式显示每个文件分配的尺寸<br>  -g                类似-l，但不列出所有者</p>
<a id="more"></a>
<h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><ul>
<li>命名英文原意：print working directory</li>
<li>功能：显示当前所在的工作目录</li>
</ul>
<h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><ul>
<li>命名英文原意：change directory</li>
<li>功能：切换目录</li>
</ul>
<h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><ul>
<li>命名英文原意：make directory</li>
<li>功能：创建新目录</li>
</ul>
<h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><ul>
<li>命名英文原意：remove directory</li>
<li>功能：删除空目录</li>
</ul>
<h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><ul>
<li>命令英文原意：concatenate and display files</li>
<li>功能：连接文件并打印到标准输出设备上</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat [选项]... [文件]...</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-E 在每一行的末尾显示$<br>-n 为显示行添加行号</p>
<h4 id="more"><a href="#more" class="headerlink" title="more"></a>more</h4><ul>
<li>功能：分页显示文件内容</li>
</ul>
<h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><ul>
<li>功能：复制文件到某一处</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp [参数] &lt;源文件路径&gt; &lt;目标文件路径&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-p ：连同文件的属性一起复制，而非使用默认方式，常用于备份<br>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行<br>-r ：递归持续复制，用于目录的复制行为<br>-u ：目标文件与源文件有差异时才会复制</p>
<h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><ul>
<li>功能：删除文件或目录</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm [参数] &lt;目标文件路径&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息<br>-i ：互动模式，在删除前会询问用户是否操作<br>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</p>
<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><ul>
<li>功能：用来寻找文件或目录</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find 路径 [参数]</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-name filename ：找出文件名为filename的文件<br>-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件<br>-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；<br>-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；</p>
<h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><ul>
<li>功能：在文件中搜索匹配的字符并进行输出</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">grep[参数] &lt;要找的字串&gt; &lt;要寻找字串的源文件&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><ul>
<li>功能：能够将用户所指定的文件或目录打包成一个文件，也可以通过指定参数开启压缩/解压缩功能</li>
<li>用法：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar [参数] &lt;文件&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>-c ：新建打包文件<br> -t ：查看打包文件的内容含有哪些文件名<br> -x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同<br>一条命令中<br> -j ：通过bzip2的支持进行压缩/解压缩<br> -z ：通过gzip的支持进行压缩/解压缩<br> -v ：在压缩/解压缩过程中，将正在处理的文件名显示出来<br> -f filename ：filename为要处理的文件<br> -C dir ：指定压缩/解压缩的目录dir</p>
<hr>
<h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><p>dpkg –list　查看已安装软件<br>sudo apt-get –purge remove 包名　卸载软件　（–purge是可选项，写上这个属性是将软件及其配置文件一并删除，如不需要删除配置文件，可执行sudo apt-get remove 包名）</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>Linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title>图像直方图均衡化及规定化</title>
    <url>/2020/03/03/%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E5%8F%8A%E8%A7%84%E5%AE%9A%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<h3 id="均衡化"><a href="#均衡化" class="headerlink" title="均衡化"></a>均衡化</h3></blockquote>
<ul>
<li>读取原图像：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; imread(&#39;fig1.jpg&#39;);</span><br></pre></td></tr></table></figure>
如果是彩色图像则需转换成灰度图像：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1&#x3D;rgb2gray(f);</span><br></pre></td></tr></table></figure></li>
<li>计算累计直方图CDF：</li>
</ul>
<ol>
<li><p>直方图概率表示：<br>$p_s(s_k)=\frac{n_k}{n}$</p>
</li>
<li><p>累计直方图表示：<br>$\sum_{i=0}^k p_s(s_i)$<br>为了减少算法复杂度，先对f排序，通过序号求CDF：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g&#x3D;reshape(f,row*cloumn,1);</span><br><span class="line">g_sort&#x3D;sortrows(g);%按灰度值排序方便统计</span><br><span class="line">[a, b, c] &#x3D; unique(g_sort);%a为不同种灰度值数组，b为不同灰度值第一次出现的索引号</span><br><span class="line">S &#x3D; [];</span><br><span class="line">for i &#x3D; 1:L</span><br><span class="line">    S(end+1) &#x3D; (b(i+1)&#x2F;n);</span><br><span class="line">end</span><br><span class="line">S(end+1) &#x3D; 1 ;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>通过映射后的数据得到均衡化的新图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; uint16(f);</span><br><span class="line">result &#x3D; f;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        result(i,j) &#x3D; floor(L*S(h(i,j)+1));</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>全代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%读取原图</span><br><span class="line">f &#x3D; imread(&#39;fig1.jpg&#39;);</span><br><span class="line">% 展示原图及直方图</span><br><span class="line">figure(&#39;NumberTitle&#39;, &#39;on&#39;, &#39;Name&#39;, &#39;原图&#39;);</span><br><span class="line">subplot(2,1,1);imshow(f),title(&#39;原图像&#39;);</span><br><span class="line">subplot(2,1,2);imhist(f),title(&#39;原图像直方图&#39;)</span><br><span class="line">[row,cloumn] &#x3D; size(f);</span><br><span class="line">%预处理</span><br><span class="line">g&#x3D;reshape(f,row*cloumn,1);</span><br><span class="line">g_sort&#x3D;sortrows(g);%按灰度值排序方便统计</span><br><span class="line">[a, b, c] &#x3D; unique(g_sort);%a为不同种灰度值数组，b为不同灰度值第一次出现的索引号</span><br><span class="line">L &#x3D; uint16(255);</span><br><span class="line">%求出n</span><br><span class="line">n &#x3D; row * cloumn;</span><br><span class="line">% %计算累计直方图CDF</span><br><span class="line">S &#x3D; [];</span><br><span class="line">for i &#x3D; 1:L</span><br><span class="line">    S(end+1) &#x3D; (b(i+1)&#x2F;n);</span><br><span class="line">end</span><br><span class="line">S(end+1) &#x3D; 1 ;</span><br><span class="line">%映射</span><br><span class="line">h &#x3D; uint16(f);</span><br><span class="line">result &#x3D; f;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        result(i,j) &#x3D; floor(L*S(h(i,j)+1));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">figure(&#39;NumberTitle&#39;, &#39;on&#39;, &#39;Name&#39;, &#39;均衡化后的图&#39;);</span><br><span class="line">subplot(2,1,1);imshow(result),title(&#39;均衡化后的图像&#39;);</span><br><span class="line">subplot(2,1,2);imhist(result),title(&#39;均衡化后的图像直方图&#39;)</span><br></pre></td></tr></table></figure></li>
<li>运行结果：<br>原图像及直方图：<img src="/image/result1.png">
均衡化后的图像及直方图：
<img src="/image/result2.png">

</li>
</ul>
<blockquote>
<h3 id="规定化"><a href="#规定化" class="headerlink" title="规定化"></a>规定化</h3></blockquote>
<ul>
<li>对数据预处理操作与以上操作相似；</li>
<li>规定一个直方图：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i&#x3D;1:128</span><br><span class="line">   p(end+1)&#x3D;-1&#x2F;127^2*(i-1)+1&#x2F;127;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;129:255  </span><br><span class="line">  p(end+1)&#x3D;1&#x2F;127^2*(i-2)-1&#x2F;127;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>计算累计直方图并映射：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S &#x3D; [0];</span><br><span class="line">for i &#x3D; 1:L-1</span><br><span class="line">    S(end+1) &#x3D; S(end) + p(i);</span><br><span class="line">end</span><br><span class="line">S(end+1) &#x3D; 1 ;</span><br><span class="line">h &#x3D; uint16(f);</span><br><span class="line">result &#x3D; f;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        result(i,j) &#x3D; floor(L*S(h(i,j)+1));</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>运行结果：<br>规定的直方图：<img src="/image/result3.png">
规定化的图像及直方图：
<img src="/image/result4.png"></li>
</ul>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>图像的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的加噪与去噪</title>
    <url>/2020/03/03/%E5%9B%BE%E5%83%8F%E7%9A%84%E5%8A%A0%E5%99%AA%E4%B8%8E%E5%8E%BB%E5%99%AA/</url>
    <content><![CDATA[<blockquote>
<h3 id="实验原图"><a href="#实验原图" class="headerlink" title="实验原图"></a>实验原图</h3><img src="/image/Fig2.jpg">
</blockquote>
<blockquote>
<h3 id="以高斯噪声为例加噪去噪"><a href="#以高斯噪声为例加噪去噪" class="headerlink" title="以高斯噪声为例加噪去噪"></a>以高斯噪声为例加噪去噪</h3><p>matlab自带的加噪函数imnoise</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g &#x3D; imnoise(f1,&#39;gaussian&#39;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>噪声图像<br><img src="/image/result5.png"></p>
</blockquote>
</blockquote>
<a id="more"></a>
<blockquote>
<h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4></blockquote>
<ol>
<li><p>就嗯算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dSigma &#x3D;0.8;</span><br><span class="line">fK1&#x3D;1.0&#x2F;(2*dSigma*dSigma);</span><br><span class="line">fK2&#x3D;fK1&#x2F;pi;</span><br><span class="line">iSize &#x3D; 3;</span><br><span class="line">step &#x3D; floor(iSize&#x2F;2 + 0.5);</span><br><span class="line">for i &#x3D; 1 : iSize</span><br><span class="line">    x&#x3D;i-step;</span><br><span class="line">    fTemp&#x3D;fK2*exp(-x*x*fK1);</span><br><span class="line">    for j &#x3D; 1 : iSize</span><br><span class="line">        y&#x3D;j-step;</span><br><span class="line">        model(x+step,y+step)&#x3D;fTemp*exp(-y*y*fK1);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">dSum &#x3D; sum(sum(model));</span><br><span class="line">model &#x3D; model&#x2F;dSum;                     %Gauss核数值归一化</span><br></pre></td></tr></table></figure>
<p>得到方差0.8的3*3的高斯滤波矩阵</p>
</li>
<li><p>见<a href="https://www.cnblogs.com/MCSFX/p/11721065.html，有空再补" target="_blank" rel="noopener">https://www.cnblogs.com/MCSFX/p/11721065.html，有空再补</a></p>
<blockquote>
<h4 id="滤波处理"><a href="#滤波处理" class="headerlink" title="滤波处理"></a>滤波处理</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g_copy &#x3D; g;</span><br><span class="line">result &#x3D; g;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        if i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; i &lt; row &amp;&amp; j&lt;cloumn</span><br><span class="line">            result(i,j) &#x3D; model(1,1)*g_copy(i-1,j-1) +model(2,1)*g_copy(i,j-1) +model(1,3)*g_copy(i-1,j+1) +model(2,1)*g_copy(i,j-1) +model(3,1)*g_copy(i+1,j-1) +model(3,2)*g_copy(i+1,j) +model(3,3)*g_copy(i+1,j+1) +model(1,2)*g_copy(i-1,j)+model(2,2)*g_copy(i,j) ;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><img src="/image/result6.png">
</blockquote>
</li>
</ol>
<blockquote>
<h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><p>这里用能减少边缘影响的半邻域均值滤波，不过这幅图没什么边缘看不出来效果<br>具体算法参看下图<br><img src="/image/reason1.png"></p>
</blockquote>
<ul>
<li>代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; uint16(g);</span><br><span class="line">result &#x3D; g;</span><br><span class="line">for i &#x3D; 2:row-1</span><br><span class="line">    for j &#x3D; 2:cloumn -1</span><br><span class="line">        model &#x3D; sort([h(i-1,j-1),h(i-1,j),h(i-1,j+1),h(i,j-1),h(i,j+1),h(i+1,j-1),h(i+1,j),h(i+1,j+1)]);</span><br><span class="line">        for z&#x3D;1:8</span><br><span class="line">            model(z) &#x3D; uint16(model(z));</span><br><span class="line">        end</span><br><span class="line">        m3 &#x3D; (model(1)+model(2)+model(3))&#x2F;3;</span><br><span class="line">        m6 &#x3D; (model(4)+model(5)+model(6)+model(7)+model(8)+h(i,j))&#x2F;6;</span><br><span class="line">        if abs(m3-m6)&lt;&#x3D;5</span><br><span class="line">            result(i,j) &#x3D; (sum(model)+h(i,j))&#x2F;9;</span><br><span class="line">        else </span><br><span class="line">            result(i,j) &#x3D; m6;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h4><img src="/image/result7.png">
</blockquote>
</li>
</ul>
<blockquote>
<h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>这个简单，直接取中位数就行，这里用了3*3邻域的中值</p>
</blockquote>
<ul>
<li>代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; uint16(g);</span><br><span class="line">result &#x3D; g;</span><br><span class="line">for i &#x3D; 2:row-1</span><br><span class="line">    for j &#x3D; 2:cloumn -1</span><br><span class="line">        model &#x3D; sort([h(i-1,j-1),h(i-1,j),h(i-1,j+1),h(i,j-1),h(i,j+1),h(i+1,j-1),h(i+1,j),h(i+1,j+1)]);</span><br><span class="line">        result(i,j) &#x3D; model(5);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="运行结果：-2"><a href="#运行结果：-2" class="headerlink" title="运行结果："></a>运行结果：</h4><img src="/image/result8.png">
</blockquote>
</li>
</ul>
<blockquote>
<h3 id="对比一下椒盐噪声下的三种滤波效果"><a href="#对比一下椒盐噪声下的三种滤波效果" class="headerlink" title="对比一下椒盐噪声下的三种滤波效果"></a>对比一下椒盐噪声下的三种滤波效果</h3><h4 id="先看加噪后的图"><a href="#先看加噪后的图" class="headerlink" title="先看加噪后的图"></a>先看加噪后的图</h4><img src="/image/result9.png">
</blockquote>
<blockquote>
<h4 id="高斯滤波后的图"><a href="#高斯滤波后的图" class="headerlink" title="高斯滤波后的图"></a>高斯滤波后的图</h4><img src="/image/result10.png">
</blockquote>
<blockquote>
<h4 id="均值滤波后的图"><a href="#均值滤波后的图" class="headerlink" title="均值滤波后的图"></a>均值滤波后的图</h4><img src="/image/result11.png">
</blockquote>
<blockquote>
<h4 id="中值滤波后的图"><a href="#中值滤波后的图" class="headerlink" title="中值滤波后的图"></a>中值滤波后的图</h4><img src="/image/result12.png">
对于椒盐噪声来说似乎中值滤波的效果最好
</blockquote>
<hr>
<p>好像每种噪声都是高斯滤波最差，不知道是不是我设计的问题qaq</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>图像的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2020/03/02/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">原题链接</a></p>
<blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>从左往右找出能完整覆盖每一个柱子的最大矩形：<br>遍历一遍，遇到比当前大的柱子就存入栈中；遇到比当前小的柱子就依次出栈直到栈顶比当前柱子大，计算出对应出栈位置的最大矩形面积为：<br>$temparea = heights[stack[-1]] * (len(heights) - stack[-2] - 1)$<br>同时与$maxarea$比较得到最终结果</p>
</blockquote>
<blockquote>
<h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestRectangleArea(self, heights: List[int]) -&gt; int:</span><br><span class="line">        max_area &#x3D; 0</span><br><span class="line">        stack &#x3D; [-1]</span><br><span class="line">        temp_area &#x3D; 0</span><br><span class="line">        for i in range(0, len(heights)):</span><br><span class="line">            while len(stack) &gt; 1 and heights[i] &lt; heights[stack[-1]]:</span><br><span class="line">                temp_area &#x3D; heights[stack.pop()] * (i - stack[-1] - 1)</span><br><span class="line">                if temp_area &gt; max_area:</span><br><span class="line">                    max_area &#x3D; temp_area</span><br><span class="line">            stack.append(i)</span><br><span class="line">        while len(stack) &gt; 1:</span><br><span class="line">            temp_area &#x3D; heights[stack[-1]] * (len(heights) - stack[-2] - 1)</span><br><span class="line">            if temp_area &gt; max_area:</span><br><span class="line">                max_area &#x3D; temp_area</span><br><span class="line">            stack.pop()</span><br><span class="line">        return max_area</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="时间上的优化"><a href="#时间上的优化" class="headerlink" title="时间上的优化"></a>时间上的优化</h4><p>在heights数组后加入一个-1，使</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while len(stack) &gt; 1:</span><br><span class="line">    temp_area &#x3D; heights[stack[-1]] * (len(heights) - stack[-2] - 1)</span><br><span class="line">    if temp_area &gt; max_area:</span><br><span class="line">        max_area &#x3D; temp_area</span><br><span class="line">    stack.pop()</span><br></pre></td></tr></table></figure>
<p>这部分代码在上一个循环就得到执行</p>
<blockquote>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4></blockquote>
<ul>
<li>时间复杂度：$O(n),n$个数字每个会被压栈弹栈各一次。</li>
<li>空间复杂度：$O(n)，$栈的大小在极端（顺序排列）情况下等于heights大小。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2020/02/27/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">原题链接</a></p>
<blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4></blockquote>
<h5 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h5><ol>
<li>先找出最高的墙heightest;</li>
<li>从左往右加到最高的墙，每次更新左边最高的墙temp；</li>
<li>同理再从右往左加到最高的墙。</li>
</ol>
<blockquote>
<h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trap(self, height: List[int]) -&gt; int:</span><br><span class="line">        if len(height) &lt;&#x3D; 1:</span><br><span class="line">            return 0 </span><br><span class="line">        heightest &#x3D; height[0]</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        for i in range(1, len(height)):</span><br><span class="line">            if height[i] &gt; heightest:</span><br><span class="line">                index &#x3D; i</span><br><span class="line">                heightest &#x3D; height[i]</span><br><span class="line">        area &#x3D; 0</span><br><span class="line">        temp &#x3D; 0</span><br><span class="line">        for i in range(index):</span><br><span class="line">            if height[i] &gt;&#x3D; temp:</span><br><span class="line">                temp &#x3D; height[i]</span><br><span class="line">            else:</span><br><span class="line">                area +&#x3D; temp - height[i]</span><br><span class="line">        temp &#x3D; height[-1]</span><br><span class="line">        for i in reversed(range(index+1, len(height))):</span><br><span class="line">            if height[i] &gt;&#x3D; temp:</span><br><span class="line">                temp &#x3D; height[i]</span><br><span class="line">            else:</span><br><span class="line">                area +&#x3D; temp - height[i]</span><br><span class="line">        return area</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4></blockquote>
<ul>
<li>时间复杂度：遍历找出最高的墙$O(n)$;从左带最高和从右到最高加起来$O(n)$;所以总共的复杂度$O(n)$；</li>
<li>空间复杂度：只用了temp和heightest存数，$O(1)$。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>像素的4连接、8连接和m连接</title>
    <url>/2020/02/25/%E5%83%8F%E7%B4%A0%E7%9A%844%E8%BF%9E%E6%8E%A5%E3%80%818%E8%BF%9E%E6%8E%A5%E5%92%8Cm%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<h3 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h3><p>位于坐标$(x,y)$处的像素p有4个水平和垂直的相邻像素，其坐标由下式给出：<br>$(x+1,y),(x-1,y),(x,y+1),(x,y-1)$<br>这组像素称为$p$的4邻域，用$N_4(p)$表示。<br>$p$的4个对角相邻像素的坐标如下：<br>$(x+1,y+1),(x-1,y-1),(x+1,y+1),(x-1,y-1)$<br>并用$N_D(p)$表示。这些点与上面4个邻点一起称为p的8邻域，用$N_8(p)$表示。</p>
<h3 id="三种连接"><a href="#三种连接" class="headerlink" title="三种连接"></a>三种连接</h3></blockquote>
<a id="more"></a>
<ul>
<li>(1) 4-连接：2个像素 p 和 q 在V 中取值且 q 在$N_4(p)$中</li>
<li>(2) 8-连接：2个像素 p 和 q 在V 中取值且 q 在$N_8(p)$中</li>
<li>(3) m-连接（混合连接）：2个像素 p 和 q 在V 中取值，且满足下列条件之一:<ol>
<li>q在 $N_4(p)$中</li>
<li>q在 $N_8(p)$中,且 $N_4(p)$ $\cap $  $N_4(q)$是空集<img src="https://img-blog.csdn.net/2018022708514895">

</li>
</ol>
</li>
</ul>
<blockquote>
<blockquote>
<p>m连接是为了消除8连接可能产生的二义性。个人感觉就是尽量不要连斜线。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>图像处理基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Bmp格式的存储方式</title>
    <url>/2020/02/23/Bmp%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h3><blockquote>
<h4 id="格式简介"><a href="#格式简介" class="headerlink" title="格式简介"></a>格式简介</h4><p>BMP是英文Bitmap（位图）的简写，它是Windows操作系统中的标准图像文件格式，在Windows环境下运行的所有图象处理软件都支持BMP图象文件格式。Windows 3.0以前的BMP图文件格式与显示设备有关，因此把这种BMP图象文件格式称为设备相关位图DDB(device-dependent bitmap）文件格式。这种格式的特点是包含的图像信息较丰富，几乎不进行压缩，但由此导致了它与生俱生来的缺点–占用磁盘空间过大。所以，目前BMP在单机上比较流行。</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4></blockquote>
<a id="more"></a>
<p>位图文件可看成由4个部分组成：位图文件头（bitmap-file header）、位图信息头（bitmap-information header）、彩色表（color table）和定义位图的字节(位图数据，即图像数据，Data Bits 或Data Body)阵列，它具有如下所示的形式。</p>
<blockquote>
<blockquote>
<h5 id="位图文件头"><a href="#位图文件头" class="headerlink" title="位图文件头"></a>位图文件头</h5><p>Windows为bmp文件头定义了如下结构体：</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagBITMAPFILEHEADER </span><br><span class="line">&#123;  </span><br><span class="line">    UINT16 bfType;    </span><br><span class="line">    DWORD bfSize; </span><br><span class="line">    UINT16 bfReserved1; </span><br><span class="line">    UINT16 bfReserved2; </span><br><span class="line">    DWORD bfOffBits;</span><br><span class="line">&#125; BITMAPFILEHEADER;</span><br></pre></td></tr></table></figure>
<p>0000h 文件标识 2 bytes 两字节的内容用来识别位图的类型：<br>‘BM’ ：Windows 3.1x,95,NT，…<br>‘BA’ ：OS/2 Bitmap Array<br>‘CI’ ：OS/2 Color Icon<br>‘CP’ ：OS/2 Color Pointer<br>‘IC’ ：OS/2 Icon<br>‘PT’ ：OS/2 Pointer<br>注：因为OS/2系统并没有被普及开，所以在编程时，你只需判断第一个标识“BM”就行。<br>0002h File Size 1 dword 用字节表示的整个文件的大小<br>0006h Reserved 1 dword 保留，必须设置为0<br>000Ah Bitmap Data Offset 1 dword 从文件开始到位图数据开始之间的数据（bitmap data）之间的偏移量<br><img src="http://images.cnblogs.com/cnblogs_com/jason_yao/bmp_6.png"></p>
<hr>
<p>位图信息用BITMAPINFO结构来定义，它由位图信息头（bitmap-information header）和彩色表（color table）组成，前者用BITMAPINFOHEADER结构定义，后者用RGBQUAD结构定义。<br>BITMAPINFO结构具有如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagBITMAPINFO &#123; &#x2F;* bmi *&#x2F;</span><br><span class="line">    BITMAPINFOHEADER bmiHeader;</span><br><span class="line">    RGBQUAD bmiColors[1];</span><br><span class="line">&#125; BITMAPINFO;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>bmiHeader<br>说明BITMAPINFOHEADER结构，其中包含了有关位图的尺寸及位格式等信息</li>
<li>bmiColors<br>说明彩色表RGBQUAD结构的阵列，其中包含索引图像的真实RGB值。</li>
</ul>
<blockquote>
<blockquote>
<h5 id="位图信息头"><a href="#位图信息头" class="headerlink" title="位图信息头"></a>位图信息头</h5><p>BITMAPINFOHEADER结构包含有位图文件的大小、压缩类型和颜色格式，其结构定义为：</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagBITMAPINFOHEADER &#123; &#x2F;* bmih *&#x2F;</span><br><span class="line">    DWORD biSize;</span><br><span class="line">    LONG biWidth;</span><br><span class="line">    LONG biHeight;</span><br><span class="line">    WORD biPlanes;</span><br><span class="line">    WORD biBitCount;</span><br><span class="line">    DWORD biCompression;</span><br><span class="line">    DWORD biSizeImage;</span><br><span class="line">    LONG biXPelsPerMeter;</span><br><span class="line">    LONG biYPelsPerMeter;</span><br><span class="line">    DWORD biClrUsed;</span><br><span class="line">    DWORD biClrImportant;</span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>biSize<br>说明BITMAPINFOHEADER结构所需要的字数。注：这个值并不一定是BITMAPINFOHEADER结构的尺寸，它也可能是sizeof(BITMAPV4HEADER）的值，或是sizeof(BITMAPV5HEADER）的值。这要根据该位图文件的格式版本来决定，不过，就现在的情况来看，绝大多数的BMP图像都是BITMAPINFOHEADER结构的（可能是后两者太新的缘故吧:-）。</li>
<li>biWidth<br>说明图象的宽度，以象素为单位</li>
<li>biHeight<br>说明图象的高度，以象素为单位。注：这个值除了用于描述图像的高度之外，它还有另一个用处，就是指明该图像是倒向的位图，还是正向的位图。如果该值是一个正数，说明图像是倒向的，如果该值是一个负数，则说明图像是正向的。大多数的BMP文件都是倒向的位图，也就是时，高度值是一个正数。（注：当高度值是一个负数时（正向图像），图像将不能被压缩（也就是说biCompression成员将不能是BI_RLE8或BI_RLE4）。</li>
<li>biPlanes<br>为目标设备说明位面数，其值将总是被设为1</li>
<li>biBitCount<br>说明比特数/象素，其值为1、4、8、16、24、或32</li>
<li>biCompression<br>说明图象数据压缩的类型。其值可以是下述值之一：</li>
<li>BI_RGB：没有压缩；</li>
<li>BI_RLE8：每个象素8比特的RLE压缩编码，压缩格式由2字节组成（重复象素计数和颜色索引）；</li>
<li>BI_RLE4：每个象素4比特的RLE压缩编码，压缩格式由2字节组成</li>
<li>BI_BITFIELDS：每个象素的比特由指定的掩码决定。</li>
<li>biSizeImage<br>说明图象的大小，以字节为单位。当用BI_RGB格式时，可设置为0</li>
<li>biXPelsPerMeter<br>说明水平分辨率，用象素/米表示</li>
<li>biYPelsPerMeter<br>说明垂直分辨率，用象素/米表示</li>
<li>biClrUsed<br>说明位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用所有调色板项）</li>
<li>biClrImportant<br>说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。<img src="http://images.cnblogs.com/cnblogs_com/jason_yao/bmp_7.png">

</li>
</ul>
<blockquote>
<blockquote>
<h5 id="彩色表定位"><a href="#彩色表定位" class="headerlink" title="彩色表定位"></a>彩色表定位</h5><p>应用程序可使用存储在biSize成员中的信息来查找在BITMAPINFO结构中的彩色表，如下所示：</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pColor &#x3D; ((LPSTR) pBitmapInfo + (WORD) (pBitmapInfo-&gt;bmiHeader.biSize))</span><br></pre></td></tr></table></figure>
<p>biBitCount<br>biBitCount=1 表示位图最多有两种颜色，缺省情况下是黑色和白色，你也可以自己定义这两种颜色。图像信息头装调色板中将有两个调色板项，称为索引0和索引1。图象数据阵列中的每一位表示一个象素。如果一个位是0，显示时就使用索引0的RGB值，如果位是1，则使用索引1的RGB值。<br>biBitCount=4 表示位图最多有16种颜色。每个象素用4位表示，并用这4位作为彩色表的表项来查找该象素的颜色。例如，如果位图中的第一个字节为0x1F，它表示有两个象素，第一象素的颜色就在彩色表的第2表项中查找，而第二个象素的颜色就在彩色表的第16表项中查找。此时，调色板中缺省情况下会有16个RGB项。对应于索引0到索引15。<br>biBitCount=8 表示位图最多有256种颜色。每个象素用8位表示，并用这8位作为彩色表的表项来查找该象素的颜色。例如，如果位图中的第一个字节为0x1F，这个象素的颜色就在彩色表的第32表项中查找。此时，缺省情况下，调色板中会有256个RGB项，对应于索引0到索引255。<br>biBitCount=16 表示位图最多有65536种颜色。每个色素用16位（2个字节）表示。这种格式叫作高彩色，或叫增强型16位色，或64K色。它的情况比较复杂，当biCompression成员的值是BI_RGB时，它没有调色板。16位中，最低的5位表示蓝色分量，中间的5位表示绿色分量，高的5位表示红色分量，一共占用了15位，最高的一位保留，设为0。这种格式也被称作555 16位位图。如果biCompression成员的值是BI_BITFIELDS，那么情况就复杂了，首先是原来调色板的位置被三个DWORD变量占据，称为红、绿、蓝掩码。分别用于描述红、绿、蓝分量在16位中所占的位置。在Windows 95（或98）中，系统可接受两种格式的位域：555和565，在555格式下，红、绿、蓝的掩码分别是：0x7C00、0x03E0、0x001F，而在565格式下，它们则分别为：0xF800、0x07E0、0x001F。你在读取一个像素之后，可以分别用掩码“与”上像素值，从而提取出想要的颜色分量（当然还要再经过适当的左右移操作）。在NT系统中，则没有格式限制，只不过要求掩码之间不能有重叠。（注：这种格式的图像使用起来是比较麻烦的，不过因为它的显示效果接近于真彩，而图像数据又比真彩图像小的多，所以，它更多的被用于游戏软件）。<br>biBitCount=24 表示位图最多有1670万种颜色。这种位图没有调色板（bmiColors成员尺寸为0），在位数组中，每3个字节代表一个象素，分别对应于颜色R、G、B。<br>biBitCount=32 表示位图最多有4294967296(2的32次方）种颜色。这种位图的结构与16位位图结构非常类似，当biCompression成员的值是BI_RGB时，它也没有调色板，32位中有24位用于存放RGB值，顺序是：最高位—保留，红8位、绿8位、蓝8位。这种格式也被成为888 32位图。如果 biCompression成员的值是BI_BITFIELDS时，原来调色板的位置将被三个DWORD变量占据，成为红、绿、蓝掩码，分别用于描述红、绿、蓝分量在32位中所占的位置。在Windows 95(or 98）中，系统只接受888格式，也就是说三个掩码的值将只能是：0xFF0000、0xFF00、0xFF。而在NT系统中，你只要注意使掩码之间不产生重叠就行。（注：这种图像格式比较规整，因为它是DWORD对齐的，所以在内存中进行图像处理时可进行汇编级的代码优化（简单））。</p>
]]></content>
      <categories>
        <category>数字图像处理</category>
      </categories>
      <tags>
        <tag>图像处理基本概念</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">themes</a></p>
<h4 id="Ayer主题说明"><a href="#Ayer主题说明" class="headerlink" title="Ayer主题说明"></a>Ayer主题说明</h4><p><a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer</a></p>
<h3 id="Github链接格式"><a href="#Github链接格式" class="headerlink" title="Github链接格式"></a>Github链接格式</h3><p><a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">Github Corners</a></p>
]]></content>
  </entry>
</search>
