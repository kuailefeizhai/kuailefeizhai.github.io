<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>图像直方图均衡化及规定化</title>
    <url>/2020/03/03/%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96%E5%8F%8A%E8%A7%84%E5%AE%9A%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<h3 id="均衡化"><a href="#均衡化" class="headerlink" title="均衡化"></a>均衡化</h3></blockquote>
<ul>
<li>读取原图像：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f &#x3D; imread(&#39;fig1.jpg&#39;);</span><br></pre></td></tr></table></figure>
如果是彩色图像则需转换成灰度图像：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f1&#x3D;rgb2gray(f);</span><br></pre></td></tr></table></figure></li>
<li>计算累计直方图CDF：</li>
</ul>
<ol>
<li><p>直方图概率表示：<br>$p_s(s_k)=\frac{n_k}{n}$</p>
</li>
<li><p>累计直方图表示：<br>$\sum_{i=0}^k p_s(s_i)$<br>为了减少算法复杂度，先对f排序，通过序号求CDF：</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g&#x3D;reshape(f,row*cloumn,1);</span><br><span class="line">g_sort&#x3D;sortrows(g);%按灰度值排序方便统计</span><br><span class="line">[a, b, c] &#x3D; unique(g_sort);%a为不同种灰度值数组，b为不同灰度值第一次出现的索引号</span><br><span class="line">S &#x3D; [];</span><br><span class="line">for i &#x3D; 1:L</span><br><span class="line">    S(end+1) &#x3D; (b(i+1)&#x2F;n);</span><br><span class="line">end</span><br><span class="line">S(end+1) &#x3D; 1 ;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>通过映射后的数据得到均衡化的新图<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; uint16(f);</span><br><span class="line">result &#x3D; f;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        result(i,j) &#x3D; floor(L*S(h(i,j)+1));</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>全代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%读取原图</span><br><span class="line">f &#x3D; imread(&#39;fig1.jpg&#39;);</span><br><span class="line">% 展示原图及直方图</span><br><span class="line">figure(&#39;NumberTitle&#39;, &#39;on&#39;, &#39;Name&#39;, &#39;原图&#39;);</span><br><span class="line">subplot(2,1,1);imshow(f),title(&#39;原图像&#39;);</span><br><span class="line">subplot(2,1,2);imhist(f),title(&#39;原图像直方图&#39;)</span><br><span class="line">[row,cloumn] &#x3D; size(f);</span><br><span class="line">%预处理</span><br><span class="line">g&#x3D;reshape(f,row*cloumn,1);</span><br><span class="line">g_sort&#x3D;sortrows(g);%按灰度值排序方便统计</span><br><span class="line">[a, b, c] &#x3D; unique(g_sort);%a为不同种灰度值数组，b为不同灰度值第一次出现的索引号</span><br><span class="line">L &#x3D; uint16(255);</span><br><span class="line">%求出n</span><br><span class="line">n &#x3D; row * cloumn;</span><br><span class="line">% %计算累计直方图CDF</span><br><span class="line">S &#x3D; [];</span><br><span class="line">for i &#x3D; 1:L</span><br><span class="line">    S(end+1) &#x3D; (b(i+1)&#x2F;n);</span><br><span class="line">end</span><br><span class="line">S(end+1) &#x3D; 1 ;</span><br><span class="line">%映射</span><br><span class="line">h &#x3D; uint16(f);</span><br><span class="line">result &#x3D; f;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        result(i,j) &#x3D; floor(L*S(h(i,j)+1));</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">figure(&#39;NumberTitle&#39;, &#39;on&#39;, &#39;Name&#39;, &#39;均衡化后的图&#39;);</span><br><span class="line">subplot(2,1,1);imshow(result),title(&#39;均衡化后的图像&#39;);</span><br><span class="line">subplot(2,1,2);imhist(result),title(&#39;均衡化后的图像直方图&#39;)</span><br></pre></td></tr></table></figure></li>
<li>运行结果：<br>原图像及直方图：<img src="/image/result1.png">
均衡化后的图像及直方图：
<img src="/image/result2.png">

</li>
</ul>
<blockquote>
<h3 id="规定化"><a href="#规定化" class="headerlink" title="规定化"></a>规定化</h3></blockquote>
<ul>
<li>对数据预处理操作与以上操作相似；</li>
<li>规定一个直方图：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i&#x3D;1:128</span><br><span class="line">   p(end+1)&#x3D;-1&#x2F;127^2*(i-1)+1&#x2F;127;</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">for i&#x3D;129:255  </span><br><span class="line">  p(end+1)&#x3D;1&#x2F;127^2*(i-2)-1&#x2F;127;</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>计算累计直方图并映射：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">S &#x3D; [0];</span><br><span class="line">for i &#x3D; 1:L-1</span><br><span class="line">    S(end+1) &#x3D; S(end) + p(i);</span><br><span class="line">end</span><br><span class="line">S(end+1) &#x3D; 1 ;</span><br><span class="line">h &#x3D; uint16(f);</span><br><span class="line">result &#x3D; f;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        result(i,j) &#x3D; floor(L*S(h(i,j)+1));</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li>运行结果：<br>规定的直方图：<img src="/image/result3.png">
规定化的图像及直方图：
<img src="/image/result4.png"></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
        <tag>图像的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>图像的加噪与去噪</title>
    <url>/2020/03/03/%E5%9B%BE%E5%83%8F%E7%9A%84%E5%8A%A0%E5%99%AA%E4%B8%8E%E5%8E%BB%E5%99%AA/</url>
    <content><![CDATA[<blockquote>
<h3 id="实验原图"><a href="#实验原图" class="headerlink" title="实验原图"></a>实验原图</h3><img src="/image/Fig2.jpg">
</blockquote>
<blockquote>
<h3 id="以高斯噪声为例加噪去噪"><a href="#以高斯噪声为例加噪去噪" class="headerlink" title="以高斯噪声为例加噪去噪"></a>以高斯噪声为例加噪去噪</h3><p>matlab自带的加噪函数imnoise</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g &#x3D; imnoise(f1,&#39;gaussian&#39;);</span><br></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>噪声图像<br><img src="/image/result5.jpg"></p>
</blockquote>
</blockquote>
<a id="more"></a>
<blockquote>
<h4 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h4></blockquote>
<ol>
<li><p>就嗯算</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dSigma &#x3D;0.8;</span><br><span class="line">fK1&#x3D;1.0&#x2F;(2*dSigma*dSigma);</span><br><span class="line">fK2&#x3D;fK1&#x2F;pi;</span><br><span class="line">iSize &#x3D; 3;</span><br><span class="line">step &#x3D; floor(iSize&#x2F;2 + 0.5);</span><br><span class="line">for i &#x3D; 1 : iSize</span><br><span class="line">    x&#x3D;i-step;</span><br><span class="line">    fTemp&#x3D;fK2*exp(-x*x*fK1);</span><br><span class="line">    for j &#x3D; 1 : iSize</span><br><span class="line">        y&#x3D;j-step;</span><br><span class="line">        model(x+step,y+step)&#x3D;fTemp*exp(-y*y*fK1);</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">dSum &#x3D; sum(sum(model));</span><br><span class="line">model &#x3D; model&#x2F;dSum;                     %Gauss核数值归一化</span><br></pre></td></tr></table></figure>
<p>得到方差0.8的3*3的高斯滤波矩阵</p>
</li>
<li><p>见<a href="https://www.cnblogs.com/MCSFX/p/11721065.html，有空再补" target="_blank" rel="noopener">https://www.cnblogs.com/MCSFX/p/11721065.html，有空再补</a></p>
<blockquote>
<h4 id="滤波处理"><a href="#滤波处理" class="headerlink" title="滤波处理"></a>滤波处理</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g_copy &#x3D; g;</span><br><span class="line">result &#x3D; g;</span><br><span class="line">for i &#x3D; 1:row</span><br><span class="line">    for j &#x3D; 1:cloumn</span><br><span class="line">        if i &gt; 1 &amp;&amp; j &gt; 1 &amp;&amp; i &lt; row &amp;&amp; j&lt;cloumn</span><br><span class="line">            result(i,j) &#x3D; model(1,1)*g_copy(i-1,j-1) +model(2,1)*g_copy(i,j-1) +model(1,3)*g_copy(i-1,j+1) +model(2,1)*g_copy(i,j-1) +model(3,1)*g_copy(i+1,j-1) +model(3,2)*g_copy(i+1,j) +model(3,3)*g_copy(i+1,j+1) +model(1,2)*g_copy(i-1,j)+model(2,2)*g_copy(i,j) ;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h4><img src="/image/result6.jpg">
</blockquote>
</li>
</ol>
<blockquote>
<h4 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h4><p>这里用能减少边缘影响的半邻域均值滤波，不过这幅图没什么边缘看不出来效果<br>具体算法参看下图<br><img src="/image/reason1.jpg"></p>
</blockquote>
<ul>
<li>代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; uint16(g);</span><br><span class="line">result &#x3D; g;</span><br><span class="line">for i &#x3D; 2:row-1</span><br><span class="line">    for j &#x3D; 2:cloumn -1</span><br><span class="line">        model &#x3D; sort([h(i-1,j-1),h(i-1,j),h(i-1,j+1),h(i,j-1),h(i,j+1),h(i+1,j-1),h(i+1,j),h(i+1,j+1)]);</span><br><span class="line">        for z&#x3D;1:8</span><br><span class="line">            model(z) &#x3D; uint16(model(z));</span><br><span class="line">        end</span><br><span class="line">        m3 &#x3D; (model(1)+model(2)+model(3))&#x2F;3;</span><br><span class="line">        m6 &#x3D; (model(4)+model(5)+model(6)+model(7)+model(8)+h(i,j))&#x2F;6;</span><br><span class="line">        if abs(m3-m6)&lt;&#x3D;5</span><br><span class="line">            result(i,j) &#x3D; (sum(model)+h(i,j))&#x2F;9;</span><br><span class="line">        else </span><br><span class="line">            result(i,j) &#x3D; m6;</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="运行结果：-1"><a href="#运行结果：-1" class="headerlink" title="运行结果："></a>运行结果：</h4><img src="/image/result7.jpg">
</blockquote>
</li>
</ul>
<blockquote>
<h4 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h4><p>这个简单，直接取中位数就行，这里用了3*3邻域的中值</p>
</blockquote>
<ul>
<li>代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">h &#x3D; uint16(g);</span><br><span class="line">result &#x3D; g;</span><br><span class="line">for i &#x3D; 2:row-1</span><br><span class="line">    for j &#x3D; 2:cloumn -1</span><br><span class="line">        model &#x3D; sort([h(i-1,j-1),h(i-1,j),h(i-1,j+1),h(i,j-1),h(i,j+1),h(i+1,j-1),h(i+1,j),h(i+1,j+1)]);</span><br><span class="line">        result(i,j) &#x3D; model(5);</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="运行结果：-2"><a href="#运行结果：-2" class="headerlink" title="运行结果："></a>运行结果：</h4><img src="/image/result8.jpg">
</blockquote>
</li>
</ul>
<blockquote>
<h3 id="对比一下椒盐噪声下的三种滤波效果"><a href="#对比一下椒盐噪声下的三种滤波效果" class="headerlink" title="对比一下椒盐噪声下的三种滤波效果"></a>对比一下椒盐噪声下的三种滤波效果</h3><h4 id="先看加噪后的图"><a href="#先看加噪后的图" class="headerlink" title="先看加噪后的图"></a>先看加噪后的图</h4><img src="/image/result9.jpg">
</blockquote>
<blockquote>
<h4 id="高斯滤波后的图"><a href="#高斯滤波后的图" class="headerlink" title="高斯滤波后的图"></a>高斯滤波后的图</h4><img src="/image/result10.jpg">
</blockquote>
<blockquote>
<h4 id="均值滤波后的图"><a href="#均值滤波后的图" class="headerlink" title="均值滤波后的图"></a>均值滤波后的图</h4><img src="/image/result11.jpg">
</blockquote>
<blockquote>
<h4 id="中值滤波后的图"><a href="#中值滤波后的图" class="headerlink" title="中值滤波后的图"></a>中值滤波后的图</h4><img src="/image/result12.jpg">
对于椒盐噪声来说似乎中值滤波的效果最好
</blockquote>
<hr>
<p>好像每种噪声都是高斯滤波最差，不知道是不是我设计的问题qaq</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
        <tag>图像的基本操作</tag>
      </tags>
  </entry>
  <entry>
    <title>柱状图中最大的矩形</title>
    <url>/2020/03/02/%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">原题链接</a></p>
<blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4><p>从左往右找出能完整覆盖每一个柱子的最大矩形：<br>遍历一遍，遇到比当前大的柱子就存入栈中；遇到比当前小的柱子就依次出栈直到栈顶比当前柱子大，计算出对应出栈位置的最大矩形面积为：<br>$temparea = heights[stack[-1]] * (len(heights) - stack[-2] - 1)$<br>同时与$maxarea$比较得到最终结果</p>
</blockquote>
<blockquote>
<h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def largestRectangleArea(self, heights: List[int]) -&gt; int:</span><br><span class="line">        max_area &#x3D; 0</span><br><span class="line">        stack &#x3D; [-1]</span><br><span class="line">        temp_area &#x3D; 0</span><br><span class="line">        for i in range(0, len(heights)):</span><br><span class="line">            while len(stack) &gt; 1 and heights[i] &lt; heights[stack[-1]]:</span><br><span class="line">                temp_area &#x3D; heights[stack.pop()] * (i - stack[-1] - 1)</span><br><span class="line">                if temp_area &gt; max_area:</span><br><span class="line">                    max_area &#x3D; temp_area</span><br><span class="line">            stack.append(i)</span><br><span class="line">        while len(stack) &gt; 1:</span><br><span class="line">            temp_area &#x3D; heights[stack[-1]] * (len(heights) - stack[-2] - 1)</span><br><span class="line">            if temp_area &gt; max_area:</span><br><span class="line">                max_area &#x3D; temp_area</span><br><span class="line">            stack.pop()</span><br><span class="line">        return max_area</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="时间上的优化"><a href="#时间上的优化" class="headerlink" title="时间上的优化"></a>时间上的优化</h4><p>在heights数组后加入一个-1，使</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while len(stack) &gt; 1:</span><br><span class="line">    temp_area &#x3D; heights[stack[-1]] * (len(heights) - stack[-2] - 1)</span><br><span class="line">    if temp_area &gt; max_area:</span><br><span class="line">        max_area &#x3D; temp_area</span><br><span class="line">    stack.pop()</span><br></pre></td></tr></table></figure>
<p>这部分代码在上一个循环就得到执行</p>
<blockquote>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4></blockquote>
<ul>
<li>时间复杂度：$O(n),n$个数字每个会被压栈弹栈各一次。</li>
<li>空间复杂度：$O(n)，$栈的大小在极端（顺序排列）情况下等于heights大小。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>接雨水</title>
    <url>/2020/02/27/%E6%8E%A5%E9%9B%A8%E6%B0%B4/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">原题链接</a></p>
<blockquote>
<h4 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h4></blockquote>
<h5 id="双指针法："><a href="#双指针法：" class="headerlink" title="双指针法："></a>双指针法：</h5><ol>
<li>先找出最高的墙heightest;</li>
<li>从左往右加到最高的墙，每次更新左边最高的墙temp；</li>
<li>同理再从右往左加到最高的墙。</li>
</ol>
<blockquote>
<h4 id="我的代码"><a href="#我的代码" class="headerlink" title="我的代码"></a>我的代码</h4></blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def trap(self, height: List[int]) -&gt; int:</span><br><span class="line">        if len(height) &lt;&#x3D; 1:</span><br><span class="line">            return 0 </span><br><span class="line">        heightest &#x3D; height[0]</span><br><span class="line">        index &#x3D; 0</span><br><span class="line">        for i in range(1, len(height)):</span><br><span class="line">            if height[i] &gt; heightest:</span><br><span class="line">                index &#x3D; i</span><br><span class="line">                heightest &#x3D; height[i]</span><br><span class="line">        area &#x3D; 0</span><br><span class="line">        temp &#x3D; 0</span><br><span class="line">        for i in range(index):</span><br><span class="line">            if height[i] &gt;&#x3D; temp:</span><br><span class="line">                temp &#x3D; height[i]</span><br><span class="line">            else:</span><br><span class="line">                area +&#x3D; temp - height[i]</span><br><span class="line">        temp &#x3D; height[-1]</span><br><span class="line">        for i in reversed(range(index+1, len(height))):</span><br><span class="line">            if height[i] &gt;&#x3D; temp:</span><br><span class="line">                temp &#x3D; height[i]</span><br><span class="line">            else:</span><br><span class="line">                area +&#x3D; temp - height[i]</span><br><span class="line">        return area</span><br></pre></td></tr></table></figure>
<blockquote>
<h4 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h4></blockquote>
<ul>
<li>时间复杂度：遍历找出最高的墙$O(n)$;从左带最高和从右到最高加起来$O(n)$;所以总共的复杂度$O(n)$；</li>
<li>空间复杂度：只用了temp和heightest存数，$O(1)$。</li>
</ul>
]]></content>
      <categories>
        <category>leetcode刷题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>栈</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>像素的4连接、8连接和m连接</title>
    <url>/2020/02/25/%E5%83%8F%E7%B4%A0%E7%9A%844%E8%BF%9E%E6%8E%A5%E3%80%818%E8%BF%9E%E6%8E%A5%E5%92%8Cm%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<blockquote>
<h3 id="相邻像素"><a href="#相邻像素" class="headerlink" title="相邻像素"></a>相邻像素</h3><p>位于坐标$(x,y)$处的像素p有4个水平和垂直的相邻像素，其坐标由下式给出：<br>$(x+1,y),(x-1,y),(x,y+1),(x,y-1)$<br>这组像素称为$p$的4邻域，用$N_4(p)$表示。<br>$p$的4个对角相邻像素的坐标如下：<br>$(x+1,y+1),(x-1,y-1),(x+1,y+1),(x-1,y-1)$<br>并用$N_D(p)$表示。这些点与上面4个邻点一起称为p的8邻域，用$N_8(p)$表示。</p>
<h3 id="三种连接"><a href="#三种连接" class="headerlink" title="三种连接"></a>三种连接</h3></blockquote>
<a id="more"></a>
<ul>
<li>(1) 4-连接：2个像素 p 和 q 在V 中取值且 q 在$N_4(p)$中</li>
<li>(2) 8-连接：2个像素 p 和 q 在V 中取值且 q 在$N_8(p)$中</li>
<li>(3) m-连接（混合连接）：2个像素 p 和 q 在V 中取值，且满足下列条件之一:<ol>
<li>q在 $N_4(p)$中</li>
<li>q在 $N_8(p)$中,且 $N_4(p)$ $\cap $  $N_4(q)$是空集<img src="https://img-blog.csdn.net/2018022708514895">

</li>
</ol>
</li>
</ul>
<blockquote>
<blockquote>
<p>m连接是为了消除8连接可能产生的二义性。个人感觉就是尽量不要连斜线。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Bmp格式的存储方式</title>
    <url>/2020/02/23/Bmp%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h3><blockquote>
<h4 id="格式简介"><a href="#格式简介" class="headerlink" title="格式简介"></a>格式简介</h4><p>BMP是英文Bitmap（位图）的简写，它是Windows操作系统中的标准图像文件格式，在Windows环境下运行的所有图象处理软件都支持BMP图象文件格式。Windows 3.0以前的BMP图文件格式与显示设备有关，因此把这种BMP图象文件格式称为设备相关位图DDB(device-dependent bitmap）文件格式。这种格式的特点是包含的图像信息较丰富，几乎不进行压缩，但由此导致了它与生俱生来的缺点–占用磁盘空间过大。所以，目前BMP在单机上比较流行。</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4></blockquote>
<a id="more"></a>
<p>位图文件可看成由4个部分组成：位图文件头（bitmap-file header）、位图信息头（bitmap-information header）、彩色表（color table）和定义位图的字节(位图数据，即图像数据，Data Bits 或Data Body)阵列，它具有如下所示的形式。</p>
<blockquote>
<blockquote>
<h5 id="位图文件头"><a href="#位图文件头" class="headerlink" title="位图文件头"></a>位图文件头</h5><p>Windows为bmp文件头定义了如下结构体：</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagBITMAPFILEHEADER </span><br><span class="line">&#123;  </span><br><span class="line">    UINT16 bfType;    </span><br><span class="line">    DWORD bfSize; </span><br><span class="line">    UINT16 bfReserved1; </span><br><span class="line">    UINT16 bfReserved2; </span><br><span class="line">    DWORD bfOffBits;</span><br><span class="line">&#125; BITMAPFILEHEADER;</span><br></pre></td></tr></table></figure>
<p>0000h 文件标识 2 bytes 两字节的内容用来识别位图的类型：<br>‘BM’ ：Windows 3.1x,95,NT，…<br>‘BA’ ：OS/2 Bitmap Array<br>‘CI’ ：OS/2 Color Icon<br>‘CP’ ：OS/2 Color Pointer<br>‘IC’ ：OS/2 Icon<br>‘PT’ ：OS/2 Pointer<br>注：因为OS/2系统并没有被普及开，所以在编程时，你只需判断第一个标识“BM”就行。<br>0002h File Size 1 dword 用字节表示的整个文件的大小<br>0006h Reserved 1 dword 保留，必须设置为0<br>000Ah Bitmap Data Offset 1 dword 从文件开始到位图数据开始之间的数据（bitmap data）之间的偏移量<br><img src="http://images.cnblogs.com/cnblogs_com/jason_yao/bmp_6.png"></p>
<hr>
<p>位图信息用BITMAPINFO结构来定义，它由位图信息头（bitmap-information header）和彩色表（color table）组成，前者用BITMAPINFOHEADER结构定义，后者用RGBQUAD结构定义。<br>BITMAPINFO结构具有如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagBITMAPINFO &#123; &#x2F;* bmi *&#x2F;</span><br><span class="line">    BITMAPINFOHEADER bmiHeader;</span><br><span class="line">    RGBQUAD bmiColors[1];</span><br><span class="line">&#125; BITMAPINFO;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>bmiHeader<br>说明BITMAPINFOHEADER结构，其中包含了有关位图的尺寸及位格式等信息</li>
<li>bmiColors<br>说明彩色表RGBQUAD结构的阵列，其中包含索引图像的真实RGB值。</li>
</ul>
<blockquote>
<blockquote>
<h5 id="位图信息头"><a href="#位图信息头" class="headerlink" title="位图信息头"></a>位图信息头</h5><p>BITMAPINFOHEADER结构包含有位图文件的大小、压缩类型和颜色格式，其结构定义为：</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct tagBITMAPINFOHEADER &#123; &#x2F;* bmih *&#x2F;</span><br><span class="line">    DWORD biSize;</span><br><span class="line">    LONG biWidth;</span><br><span class="line">    LONG biHeight;</span><br><span class="line">    WORD biPlanes;</span><br><span class="line">    WORD biBitCount;</span><br><span class="line">    DWORD biCompression;</span><br><span class="line">    DWORD biSizeImage;</span><br><span class="line">    LONG biXPelsPerMeter;</span><br><span class="line">    LONG biYPelsPerMeter;</span><br><span class="line">    DWORD biClrUsed;</span><br><span class="line">    DWORD biClrImportant;</span><br><span class="line">&#125; BITMAPINFOHEADER;</span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>biSize<br>说明BITMAPINFOHEADER结构所需要的字数。注：这个值并不一定是BITMAPINFOHEADER结构的尺寸，它也可能是sizeof(BITMAPV4HEADER）的值，或是sizeof(BITMAPV5HEADER）的值。这要根据该位图文件的格式版本来决定，不过，就现在的情况来看，绝大多数的BMP图像都是BITMAPINFOHEADER结构的（可能是后两者太新的缘故吧:-）。</li>
<li>biWidth<br>说明图象的宽度，以象素为单位</li>
<li>biHeight<br>说明图象的高度，以象素为单位。注：这个值除了用于描述图像的高度之外，它还有另一个用处，就是指明该图像是倒向的位图，还是正向的位图。如果该值是一个正数，说明图像是倒向的，如果该值是一个负数，则说明图像是正向的。大多数的BMP文件都是倒向的位图，也就是时，高度值是一个正数。（注：当高度值是一个负数时（正向图像），图像将不能被压缩（也就是说biCompression成员将不能是BI_RLE8或BI_RLE4）。</li>
<li>biPlanes<br>为目标设备说明位面数，其值将总是被设为1</li>
<li>biBitCount<br>说明比特数/象素，其值为1、4、8、16、24、或32</li>
<li>biCompression<br>说明图象数据压缩的类型。其值可以是下述值之一：</li>
<li>BI_RGB：没有压缩；</li>
<li>BI_RLE8：每个象素8比特的RLE压缩编码，压缩格式由2字节组成（重复象素计数和颜色索引）；</li>
<li>BI_RLE4：每个象素4比特的RLE压缩编码，压缩格式由2字节组成</li>
<li>BI_BITFIELDS：每个象素的比特由指定的掩码决定。</li>
<li>biSizeImage<br>说明图象的大小，以字节为单位。当用BI_RGB格式时，可设置为0</li>
<li>biXPelsPerMeter<br>说明水平分辨率，用象素/米表示</li>
<li>biYPelsPerMeter<br>说明垂直分辨率，用象素/米表示</li>
<li>biClrUsed<br>说明位图实际使用的彩色表中的颜色索引数（设为0的话，则说明使用所有调色板项）</li>
<li>biClrImportant<br>说明对图象显示有重要影响的颜色索引的数目，如果是0，表示都重要。<img src="http://images.cnblogs.com/cnblogs_com/jason_yao/bmp_7.png">

</li>
</ul>
<blockquote>
<blockquote>
<h5 id="彩色表定位"><a href="#彩色表定位" class="headerlink" title="彩色表定位"></a>彩色表定位</h5><p>应用程序可使用存储在biSize成员中的信息来查找在BITMAPINFO结构中的彩色表，如下所示：</p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pColor &#x3D; ((LPSTR) pBitmapInfo + (WORD) (pBitmapInfo-&gt;bmiHeader.biSize))</span><br></pre></td></tr></table></figure>
<p>biBitCount<br>biBitCount=1 表示位图最多有两种颜色，缺省情况下是黑色和白色，你也可以自己定义这两种颜色。图像信息头装调色板中将有两个调色板项，称为索引0和索引1。图象数据阵列中的每一位表示一个象素。如果一个位是0，显示时就使用索引0的RGB值，如果位是1，则使用索引1的RGB值。<br>biBitCount=4 表示位图最多有16种颜色。每个象素用4位表示，并用这4位作为彩色表的表项来查找该象素的颜色。例如，如果位图中的第一个字节为0x1F，它表示有两个象素，第一象素的颜色就在彩色表的第2表项中查找，而第二个象素的颜色就在彩色表的第16表项中查找。此时，调色板中缺省情况下会有16个RGB项。对应于索引0到索引15。<br>biBitCount=8 表示位图最多有256种颜色。每个象素用8位表示，并用这8位作为彩色表的表项来查找该象素的颜色。例如，如果位图中的第一个字节为0x1F，这个象素的颜色就在彩色表的第32表项中查找。此时，缺省情况下，调色板中会有256个RGB项，对应于索引0到索引255。<br>biBitCount=16 表示位图最多有65536种颜色。每个色素用16位（2个字节）表示。这种格式叫作高彩色，或叫增强型16位色，或64K色。它的情况比较复杂，当biCompression成员的值是BI_RGB时，它没有调色板。16位中，最低的5位表示蓝色分量，中间的5位表示绿色分量，高的5位表示红色分量，一共占用了15位，最高的一位保留，设为0。这种格式也被称作555 16位位图。如果biCompression成员的值是BI_BITFIELDS，那么情况就复杂了，首先是原来调色板的位置被三个DWORD变量占据，称为红、绿、蓝掩码。分别用于描述红、绿、蓝分量在16位中所占的位置。在Windows 95（或98）中，系统可接受两种格式的位域：555和565，在555格式下，红、绿、蓝的掩码分别是：0x7C00、0x03E0、0x001F，而在565格式下，它们则分别为：0xF800、0x07E0、0x001F。你在读取一个像素之后，可以分别用掩码“与”上像素值，从而提取出想要的颜色分量（当然还要再经过适当的左右移操作）。在NT系统中，则没有格式限制，只不过要求掩码之间不能有重叠。（注：这种格式的图像使用起来是比较麻烦的，不过因为它的显示效果接近于真彩，而图像数据又比真彩图像小的多，所以，它更多的被用于游戏软件）。<br>biBitCount=24 表示位图最多有1670万种颜色。这种位图没有调色板（bmiColors成员尺寸为0），在位数组中，每3个字节代表一个象素，分别对应于颜色R、G、B。<br>biBitCount=32 表示位图最多有4294967296(2的32次方）种颜色。这种位图的结构与16位位图结构非常类似，当biCompression成员的值是BI_RGB时，它也没有调色板，32位中有24位用于存放RGB值，顺序是：最高位—保留，红8位、绿8位、蓝8位。这种格式也被成为888 32位图。如果 biCompression成员的值是BI_BITFIELDS时，原来调色板的位置将被三个DWORD变量占据，成为红、绿、蓝掩码，分别用于描述红、绿、蓝分量在32位中所占的位置。在Windows 95(or 98）中，系统只接受888格式，也就是说三个掩码的值将只能是：0xFF0000、0xFF00、0xFF。而在NT系统中，你只要注意使掩码之间不产生重叠就行。（注：这种图像格式比较规整，因为它是DWORD对齐的，所以在内存中进行图像处理时可进行汇编级的代码优化（简单））。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>数字图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/02/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="hexo主题"><a href="#hexo主题" class="headerlink" title="hexo主题"></a>hexo主题</h3><p><a href="https://hexo.io/themes/" target="_blank" rel="noopener">themes</a></p>
<h4 id="Ayer主题说明"><a href="#Ayer主题说明" class="headerlink" title="Ayer主题说明"></a>Ayer主题说明</h4><p><a href="https://shen-yu.gitee.io/2019/ayer/" target="_blank" rel="noopener">Ayer</a></p>
<h3 id="Github链接格式"><a href="#Github链接格式" class="headerlink" title="Github链接格式"></a>Github链接格式</h3><p><a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">Github Corners</a></p>
]]></content>
  </entry>
</search>
